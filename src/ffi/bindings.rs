/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const RENDER_MANUAL: u32 = 0;
pub const RENDER_AUTOMATIC: u32 = 1;
pub const CONSOLE_WIDTH: u32 = 64;
pub const CONSOLE_HEIGHT: u32 = 28;
pub const TAB_WIDTH: u32 = 4;
pub const HORIZONTAL_PADDING: u32 = 64;
pub const VERTICAL_PADDING: u32 = 8;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const DEBUG_FEATURE_LOG_USB: u32 = 1;
pub const DEBUG_FEATURE_LOG_ISVIEWER: u32 = 2;
pub const DEBUG_FEATURE_LOG_SD: u32 = 4;
pub const DEBUG_FEATURE_FILE_SD: u32 = 8;
pub const DEBUG_FEATURE_ALL: u32 = 255;
pub const JOYBUS_BLOCK_SIZE: u32 = 64;
pub const CONTROLLER_1_INSERTED: u32 = 61440;
pub const CONTROLLER_2_INSERTED: u32 = 3840;
pub const CONTROLLER_3_INSERTED: u32 = 240;
pub const CONTROLLER_4_INSERTED: u32 = 15;
pub const ACCESSORY_NONE: u32 = 0;
pub const ACCESSORY_MEMPAK: u32 = 1;
pub const ACCESSORY_RUMBLEPAK: u32 = 2;
pub const ACCESSORY_VRU: u32 = 3;
pub const ACCESSORY_TRANSFERPAK: u32 = 4;
pub const ERROR_NONE: u32 = 0;
pub const ERROR_BAD_COMMAND: u32 = 1;
pub const ERROR_NOT_PRESENT: u32 = 2;
pub const MEMPAK_BLOCK_SIZE: u32 = 256;
pub const TPAK_ERROR_INVALID_ARGUMENT: i32 = -1;
pub const TPAK_ERROR_NO_TPAK: i32 = -2;
pub const TPAK_ERROR_NO_CONTROLLER: i32 = -3;
pub const TPAK_ERROR_UNKNOWN_BEHAVIOUR: i32 = -4;
pub const TPAK_ERROR_NO_CARTRIDGE: i32 = -5;
pub const TPAK_ERROR_ADDRESS_OVERFLOW: i32 = -6;
pub const TPAK_STATUS_READY: u32 = 1;
pub const TPAK_STATUS_WAS_RESET: u32 = 4;
pub const TPAK_STATUS_IS_RESETTING: u32 = 8;
pub const TPAK_STATUS_REMOVED: u32 = 64;
pub const TPAK_STATUS_POWERED: u32 = 128;
pub const DFS_DEFAULT_LOCATION: u32 = 2953842688;
pub const MAX_OPEN_FILES: u32 = 4;
pub const MAX_FILENAME_LEN: u32 = 243;
pub const MAX_DIRECTORY_DEPTH: u32 = 100;
pub const DFS_ESUCCESS: u32 = 0;
pub const DFS_EBADINPUT: i32 = -1;
pub const DFS_ENOFILE: i32 = -2;
pub const DFS_EBADFS: i32 = -3;
pub const DFS_ENOMEM: i32 = -4;
pub const DFS_EBADHANDLE: i32 = -5;
pub const FLAGS_FILE: u32 = 0;
pub const FLAGS_DIR: u32 = 1;
pub const FLAGS_EOF: u32 = 2;
pub const EEPROM_BLOCK_SIZE: u32 = 8;
pub const EEPFS_ESUCCESS: u32 = 0;
pub const EEPFS_EBADINPUT: i32 = -1;
pub const EEPFS_ENOFILE: i32 = -2;
pub const EEPFS_EBADFS: i32 = -3;
pub const EEPFS_ENOMEM: i32 = -4;
pub const EEPFS_EBADHANDLE: i32 = -5;
pub const EEPFS_ECONFLICT: i32 = -6;
pub const _ASSERT_H: u32 = 1;
pub const C0_STATUS_IE: u32 = 1;
pub const C0_STATUS_EXL: u32 = 2;
pub const C0_STATUS_ERL: u32 = 4;
pub const C0_CAUSE_BD: u32 = 2147483648;
pub const C0_CAUSE_CE: u32 = 805306368;
pub const C0_CAUSE_EXC_CODE: u32 = 124;
pub const C0_INTERRUPT_0: u32 = 256;
pub const C0_INTERRUPT_1: u32 = 512;
pub const C0_INTERRUPT_2: u32 = 1024;
pub const C0_INTERRUPT_3: u32 = 2048;
pub const C0_INTERRUPT_4: u32 = 4096;
pub const C0_INTERRUPT_5: u32 = 8192;
pub const C0_INTERRUPT_6: u32 = 16384;
pub const C0_INTERRUPT_7: u32 = 32768;
pub const C0_INTERRUPT_RCP: u32 = 1024;
pub const C0_INTERRUPT_CART: u32 = 2048;
pub const C0_INTERRUPT_PRENMI: u32 = 4096;
pub const C0_INTERRUPT_TIMER: u32 = 32768;
pub const C0_ENTRYLO_GLOBAL: u32 = 1;
pub const C0_ENTRYLO_VALID: u32 = 2;
pub const C0_ENTRYLO_DIRTY: u32 = 4;
pub const C0_INDEX_PROBE_FAILED: u32 = 2147483648;
pub const C1_FLAG_INEXACT_OP: u32 = 4;
pub const C1_FLAG_UNDERFLOW: u32 = 8;
pub const C1_FLAG_OVERFLOW: u32 = 16;
pub const C1_FLAG_DIV_BY_0: u32 = 32;
pub const C1_FLAG_INVALID_OP: u32 = 64;
pub const C1_ENABLE_INEXACT_OP: u32 = 128;
pub const C1_ENABLE_UNDERFLOW: u32 = 256;
pub const C1_ENABLE_OVERFLOW: u32 = 512;
pub const C1_ENABLE_DIV_BY_0: u32 = 1024;
pub const C1_ENABLE_INVALID_OP: u32 = 2048;
pub const C1_CAUSE_INEXACT_OP: u32 = 4096;
pub const C1_CAUSE_UNDERFLOW: u32 = 8192;
pub const C1_CAUSE_OVERFLOW: u32 = 16384;
pub const C1_CAUSE_DIV_BY_0: u32 = 32768;
pub const C1_CAUSE_INVALID_OP: u32 = 65536;
pub const C1_CAUSE_NOT_IMPLEMENTED: u32 = 131072;
pub const C1_FCR31_FS: u32 = 16777216;
pub const SP_STATUS_HALTED: u32 = 1;
pub const SP_STATUS_BROKE: u32 = 2;
pub const SP_STATUS_DMA_BUSY: u32 = 4;
pub const SP_STATUS_DMA_FULL: u32 = 8;
pub const SP_STATUS_IO_BUSY: u32 = 16;
pub const SP_STATUS_SSTEP: u32 = 32;
pub const SP_STATUS_INTERRUPT_ON_BREAK: u32 = 64;
pub const SP_STATUS_SIG0: u32 = 128;
pub const SP_STATUS_SIG1: u32 = 256;
pub const SP_STATUS_SIG2: u32 = 512;
pub const SP_STATUS_SIG3: u32 = 1024;
pub const SP_STATUS_SIG4: u32 = 2048;
pub const SP_STATUS_SIG5: u32 = 4096;
pub const SP_STATUS_SIG6: u32 = 8192;
pub const SP_STATUS_SIG7: u32 = 16384;
pub const SP_WSTATUS_CLEAR_HALT: u32 = 1;
pub const SP_WSTATUS_SET_HALT: u32 = 2;
pub const SP_WSTATUS_CLEAR_BROKE: u32 = 4;
pub const SP_WSTATUS_CLEAR_INTR: u32 = 8;
pub const SP_WSTATUS_SET_INTR: u32 = 16;
pub const SP_WSTATUS_CLEAR_SSTEP: u32 = 32;
pub const SP_WSTATUS_SET_SSTEP: u32 = 64;
pub const SP_WSTATUS_CLEAR_INTR_BREAK: u32 = 128;
pub const SP_WSTATUS_SET_INTR_BREAK: u32 = 256;
pub const SP_WSTATUS_CLEAR_SIG0: u32 = 512;
pub const SP_WSTATUS_SET_SIG0: u32 = 1024;
pub const SP_WSTATUS_CLEAR_SIG1: u32 = 2048;
pub const SP_WSTATUS_SET_SIG1: u32 = 4096;
pub const SP_WSTATUS_CLEAR_SIG2: u32 = 8192;
pub const SP_WSTATUS_SET_SIG2: u32 = 16384;
pub const SP_WSTATUS_CLEAR_SIG3: u32 = 32768;
pub const SP_WSTATUS_SET_SIG3: u32 = 65536;
pub const SP_WSTATUS_CLEAR_SIG4: u32 = 131072;
pub const SP_WSTATUS_SET_SIG4: u32 = 262144;
pub const SP_WSTATUS_CLEAR_SIG5: u32 = 524288;
pub const SP_WSTATUS_SET_SIG5: u32 = 1048576;
pub const SP_WSTATUS_CLEAR_SIG6: u32 = 2097152;
pub const SP_WSTATUS_SET_SIG6: u32 = 4194304;
pub const SP_WSTATUS_CLEAR_SIG7: u32 = 8388608;
pub const SP_WSTATUS_SET_SIG7: u32 = 16777216;
pub const TF_ONE_SHOT: u32 = 0;
pub const TF_CONTINUOUS: u32 = 1;
pub const TF_DISABLED: u32 = 2;
pub const DT_REG: u32 = 1;
pub const DT_DIR: u32 = 2;
pub const MIXER_MAX_CHANNELS: u32 = 32;
pub const MIXER_LOOP_OVERREAD: u32 = 64;
pub const WAVEFORM_MAX_LEN: u32 = 536870911;
pub const WAVEFORM_UNKNOWN_LEN: u32 = 536870911;
pub const AY8910_DECIMATE: u32 = 3;
pub const AY8910_OUTPUT_STEREO: u32 = 1;
pub const AY8910_VOLUME_ATTENUATE: f64 = 0.8;
pub const AY8910_CENTER_SILENCE: u32 = 1;
pub const RSPQ_MAX_COMMAND_SIZE: u32 = 63;
pub const RSPQ_MAX_SHORT_COMMAND_SIZE: u32 = 16;
pub const SURFACE_FLAGS_TEXFORMAT: u32 = 31;
pub const SURFACE_FLAGS_OWNEDBUFFER: u32 = 32;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " @brief Will be called periodically when more sample data is needed.\n\n @param[in] buffer\n            The address to write the sample data to\n @param[in] numsamples\n            The number of samples to write to the buffer\n            Note: this is the number of samples per channel, so clients\n            should write twice this number of samples (interleaved)."]
pub type audio_fill_buffer_callback = ::std::option::Option<
    unsafe extern "C" fn(buffer: *mut ::std::os::raw::c_short, numsamples: usize),
>;
extern "C" {
    pub fn audio_init(frequency: ::std::os::raw::c_int, numbuffers: ::std::os::raw::c_int);
}
extern "C" {
    pub fn audio_set_buffer_callback(fill_buffer_callback: audio_fill_buffer_callback);
}
extern "C" {
    pub fn audio_pause(pause: bool);
}
extern "C" {
    pub fn audio_write(buffer: *const ::std::os::raw::c_short);
}
extern "C" {
    pub fn audio_can_write() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn audio_write_silence();
}
extern "C" {
    pub fn audio_close();
}
extern "C" {
    pub fn audio_get_frequency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn audio_get_buffer_length() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn audio_write_begin() -> *mut ::std::os::raw::c_short;
}
extern "C" {
    pub fn audio_write_end();
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "@cond"]
pub type surface_t = surface_s;
#[doc = " @brief Video resolution structure\n\n You can either use one of the pre-defined constants\n (such as #RESOLUTION_320x240) or define a custom resolution."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resolution_t {
    #[doc = " @brief Screen width (must be between 1 and 800)"]
    pub width: i32,
    #[doc = " @brief Screen height (must be between 1 and 600)"]
    pub height: i32,
    #[doc = " @brief True if interlaced mode enabled"]
    pub interlaced: bool,
}
#[test]
fn bindgen_test_layout_resolution_t() {
    const UNINIT: ::std::mem::MaybeUninit<resolution_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<resolution_t>(),
        12usize,
        concat!("Size of: ", stringify!(resolution_t))
    );
    assert_eq!(
        ::std::mem::align_of::<resolution_t>(),
        4usize,
        concat!("Alignment of ", stringify!(resolution_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(resolution_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(resolution_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaced) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(resolution_t),
            "::",
            stringify!(interlaced)
        )
    );
}
extern "C" {
    #[doc = "@endcond\n** @brief 256x240 mode */"]
    pub static RESOLUTION_256x240: resolution_t;
}
extern "C" {
    #[doc = " @brief 320x240 mode"]
    pub static RESOLUTION_320x240: resolution_t;
}
extern "C" {
    #[doc = " @brief 512x240 mode, high-res progressive"]
    pub static RESOLUTION_512x240: resolution_t;
}
extern "C" {
    #[doc = " @brief 640x240 mode, high-res progressive"]
    pub static RESOLUTION_640x240: resolution_t;
}
extern "C" {
    #[doc = " @brief 512x480 mode, interlaced"]
    pub static RESOLUTION_512x480: resolution_t;
}
extern "C" {
    #[doc = " @brief 640x480 mode, interlaced"]
    pub static RESOLUTION_640x480: resolution_t;
}
#[doc = " @brief 16 bits per pixel (5-5-5-1)"]
pub const bitdepth_t_DEPTH_16_BPP: bitdepth_t = 0;
#[doc = " @brief 32 bits per pixel (8-8-8-8)"]
pub const bitdepth_t_DEPTH_32_BPP: bitdepth_t = 1;
#[doc = " @brief Valid bit depths"]
pub type bitdepth_t = ::std::os::raw::c_uint;
#[doc = " @brief Uncorrected gamma"]
pub const gamma_t_GAMMA_NONE: gamma_t = 0;
#[doc = " @brief Corrected gamma"]
pub const gamma_t_GAMMA_CORRECT: gamma_t = 1;
#[doc = " @brief Corrected gamma with hardware dither"]
pub const gamma_t_GAMMA_CORRECT_DITHER: gamma_t = 2;
#[doc = " @brief Valid gamma correction settings"]
pub type gamma_t = ::std::os::raw::c_uint;
#[doc = " @brief No anti-aliasing"]
pub const antialias_t_ANTIALIAS_OFF: antialias_t = 0;
#[doc = " @brief Resampling anti-aliasing"]
pub const antialias_t_ANTIALIAS_RESAMPLE: antialias_t = 1;
#[doc = " @brief Anti-aliasing and resampling with fetch-on-need"]
pub const antialias_t_ANTIALIAS_RESAMPLE_FETCH_NEEDED: antialias_t = 2;
#[doc = " @brief Anti-aliasing and resampling with fetch-always"]
pub const antialias_t_ANTIALIAS_RESAMPLE_FETCH_ALWAYS: antialias_t = 3;
#[doc = " @brief Valid antialiasing settings"]
pub type antialias_t = ::std::os::raw::c_uint;
#[doc = " @brief Display context (DEPRECATED: Use #surface_t instead)\n\n @see #surface_t"]
pub type display_context_t = *mut surface_t;
extern "C" {
    #[doc = " @brief Initialize the display to a particular resolution and bit depth\n\n Initialize video system.  This sets up a double, triple, or multiple\n buffered drawing surface which can be blitted or rendered to using\n software or hardware.\n\n @param[in] res\n            The requested resolution. Use eiter one of the pre-defined\n            resolution (such as #RESOLUTION_320x240) or define a custom one.\n @param[in] bit\n            The requested bit depth (#DEPTH_16_BPP or #DEPTH_32_BPP)\n @param[in] num_buffers\n            Number of buffers, usually 2 or 3, but can be more. Triple buffering\n            is recommended in case the application cannot hold a steady full framerate,\n            so that slowdowns don't impact too much.\n @param[in] gamma\n            The requested gamma setting\n @param[in] aa\n            The requested anti-aliasing setting"]
    pub fn display_init(
        res: resolution_t,
        bit: bitdepth_t,
        num_buffers: u32,
        gamma: gamma_t,
        aa: antialias_t,
    );
}
extern "C" {
    #[doc = " @brief Close the display\n\n Close a display and free buffer memory associated with it."]
    pub fn display_close();
}
extern "C" {
    #[doc = " @brief Lock a display buffer for rendering\n\n Grab a surface that is safe for drawing.  If none is available\n then this will return 0, without blocking.\n\n When you are done drawing on the buffer, use #display_show to unlock\n the surface and schedule the buffer to be displayed on the screen during\n next vblank.\n\n It is possible to lock more than a display buffer at the same time, for\n instance to begin working on a new frame while the previous one is still\n being rendered in parallel through RDP. It is important to notice that\n surfaces will always be shown on the screen in locking order,\n irrespective of the order #display_show is called.\n\n @return A valid surface to render to or NULL if none is available."]
    pub fn display_lock() -> *mut surface_t;
}
extern "C" {
    #[doc = " @brief Display a previously locked buffer\n\n Display a previously-locked surface to the screen on the next vblank. The\n surface should be locked via #display_lock.\n\n This function does not accept any arbitrary surface, but only those returned\n by #display_lock.\n\n @param[in] surf\n            A surface to show (previously retrieved using #display_lock)"]
    pub fn display_show(surf: *mut surface_t);
}
extern "C" {
    #[doc = " @brief Get the currently configured width of the display in pixels"]
    pub fn display_get_width() -> u32;
}
extern "C" {
    #[doc = " @brief Get the currently configured height of the display in pixels"]
    pub fn display_get_height() -> u32;
}
extern "C" {
    #[doc = " @brief Get the currently configured bitdepth of the display (in bytes per pixels)"]
    pub fn display_get_bitdepth() -> u32;
}
extern "C" {
    #[doc = " @brief Get the currently configured number of buffers"]
    pub fn display_get_num_buffers() -> u32;
}
extern "C" {
    pub fn console_init();
}
extern "C" {
    pub fn console_close();
}
extern "C" {
    pub fn console_set_debug(debug: bool);
}
extern "C" {
    pub fn console_set_render_mode(mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn console_clear();
}
extern "C" {
    pub fn console_render();
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initialize USB logging."]
    pub fn debug_init_usblog() -> bool;
}
extern "C" {
    #[doc = " @brief Initialize ISViewer logging."]
    pub fn debug_init_isviewer() -> bool;
}
extern "C" {
    #[doc = " @brief Initialize SD logging."]
    pub fn debug_init_sdlog(
        fn_: *const ::std::os::raw::c_char,
        openfmt: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Initialize SD filesystem"]
    pub fn debug_init_sdfs(
        prefix: *const ::std::os::raw::c_char,
        npart: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Shutdown SD filesystem."]
    pub fn debug_close_sdfs();
}
extern "C" {
    #[doc = " @brief Do a hexdump of the specified buffer via #debugf\n\n This is useful to dump a binary buffer for debugging purposes. The hexdump shown\n contains both the hexadecimal and ASCII values, similar to what hex editors do.\n\n Sample output:\n\n <pre>\n 0000  80 80 80 80 80 80 80 80  80 80 80 80 80 80 80 80   |................|\n 0010  45 67 cd ef aa aa aa aa  aa aa aa aa aa aa aa aa   |Eg..............|\n 0020  9a bc 12 34 80 80 80 80  80 80 80 80 80 80 80 80   |...4............|\n 0030  aa aa aa aa aa aa aa aa  ef 01 67 89 aa aa aa aa   |..........g.....|\n 0040  80 80 80 80 80 80 80 80  00 00 00 00 80 80 80 80   |................|\n </pre>\n\n @param[in] buffer \tBuffer to dump\n @param[in] size \t\tSize of the buffer in bytes"]
    pub fn debug_hexdump(buffer: *const ::std::os::raw::c_void, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Underlying implementation function for assert() and #assertf."]
    pub fn debug_assert_func_f(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        failedexpr: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
extern "C" {
    pub fn joybus_exec(
        inblock: *const ::std::os::raw::c_void,
        outblock: *mut ::std::os::raw::c_void,
    );
}
#[doc = " @brief SI Nintendo 64 controller data\n\n Data structure for Joybus response to `0x01` (Read N64 controller state) command."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SI_condat {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_1: SI_condat__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SI_condat__bindgen_ty_1 {
    pub __bindgen_anon_1: SI_condat__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: SI_condat__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SI_condat__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SI_condat__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SI_condat__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SI_condat__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SI_condat__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SI_condat__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl SI_condat__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let data: u32 = unsafe { ::std::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SI_condat__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SI_condat__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<SI_condat__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SI_condat__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SI_condat__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SI_condat__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl SI_condat__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn A(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_A(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn down(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_down(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn left(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_left(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn right(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_right(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn L(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_L(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn R(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_R(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C_up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C_down(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C_down(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C_left(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C_left(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C_right(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C_right(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_x(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn y(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_y(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        A: ::std::os::raw::c_uint,
        B: ::std::os::raw::c_uint,
        Z: ::std::os::raw::c_uint,
        start: ::std::os::raw::c_uint,
        up: ::std::os::raw::c_uint,
        down: ::std::os::raw::c_uint,
        left: ::std::os::raw::c_uint,
        right: ::std::os::raw::c_uint,
        L: ::std::os::raw::c_uint,
        R: ::std::os::raw::c_uint,
        C_up: ::std::os::raw::c_uint,
        C_down: ::std::os::raw::c_uint,
        C_left: ::std::os::raw::c_uint,
        C_right: ::std::os::raw::c_uint,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let A: u32 = unsafe { ::std::mem::transmute(A) };
            A as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let B: u32 = unsafe { ::std::mem::transmute(B) };
            B as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Z: u32 = unsafe { ::std::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let start: u32 = unsafe { ::std::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let up: u32 = unsafe { ::std::mem::transmute(up) };
            up as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let down: u32 = unsafe { ::std::mem::transmute(down) };
            down as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let left: u32 = unsafe { ::std::mem::transmute(left) };
            left as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let right: u32 = unsafe { ::std::mem::transmute(right) };
            right as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let L: u32 = unsafe { ::std::mem::transmute(L) };
            L as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let R: u32 = unsafe { ::std::mem::transmute(R) };
            R as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let C_up: u32 = unsafe { ::std::mem::transmute(C_up) };
            C_up as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let C_down: u32 = unsafe { ::std::mem::transmute(C_down) };
            C_down as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let C_left: u32 = unsafe { ::std::mem::transmute(C_left) };
            C_left as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let C_right: u32 = unsafe { ::std::mem::transmute(C_right) };
            C_right as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let x: u32 = unsafe { ::std::mem::transmute(x) };
            x as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let y: u32 = unsafe { ::std::mem::transmute(y) };
            y as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SI_condat__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SI_condat__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SI_condat__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SI_condat__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SI_condat__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_SI_condat() {
    assert_eq!(
        ::std::mem::size_of::<SI_condat>(),
        8usize,
        concat!("Size of: ", stringify!(SI_condat))
    );
    assert_eq!(
        ::std::mem::align_of::<SI_condat>(),
        4usize,
        concat!("Alignment of ", stringify!(SI_condat))
    );
}
impl SI_condat {
    #[inline]
    pub fn err(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_err(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(err: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let err: u32 = unsafe { ::std::mem::transmute(err) };
            err as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief SI Nintendo 64 controller data\n\n Data structure for Joybus response to `0x01` (Read N64 controller state) command."]
pub type _SI_condat = SI_condat;
#[doc = " @brief SI GameCube controller data.\n\n Data structure for Joybus response to `0x40` (Read GC controller state) command."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SI_condat_gc {
    pub __bindgen_anon_1: SI_condat_gc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SI_condat_gc__bindgen_ty_1 {
    pub __bindgen_anon_1: SI_condat_gc__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: SI_condat_gc__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SI_condat_gc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " @brief 64-bit data sent to or returned from SI"]
    pub data: u64,
}
#[test]
fn bindgen_test_layout_SI_condat_gc__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SI_condat_gc__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SI_condat_gc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SI_condat_gc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SI_condat_gc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SI_condat_gc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SI_condat_gc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SI_condat_gc__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_SI_condat_gc__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<SI_condat_gc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SI_condat_gc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SI_condat_gc__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SI_condat_gc__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl SI_condat_gc__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn err(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_err(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn origin_unchecked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_origin_unchecked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn y(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_y(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn b(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_b(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn a(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_a(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unused2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn r(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_r(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn z(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_z(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn down(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_down(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn right(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_right(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn left(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_left(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stick_x(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_stick_x(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn stick_y(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_stick_y(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cstick_x(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cstick_x(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cstick_y(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cstick_y(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn analog_l(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_analog_l(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn analog_r(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_analog_r(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        err: ::std::os::raw::c_uint,
        origin_unchecked: ::std::os::raw::c_uint,
        start: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        x: ::std::os::raw::c_uint,
        b: ::std::os::raw::c_uint,
        a: ::std::os::raw::c_uint,
        unused2: ::std::os::raw::c_uint,
        l: ::std::os::raw::c_uint,
        r: ::std::os::raw::c_uint,
        z: ::std::os::raw::c_uint,
        up: ::std::os::raw::c_uint,
        down: ::std::os::raw::c_uint,
        right: ::std::os::raw::c_uint,
        left: ::std::os::raw::c_uint,
        stick_x: ::std::os::raw::c_uint,
        stick_y: ::std::os::raw::c_uint,
        cstick_x: ::std::os::raw::c_uint,
        cstick_y: ::std::os::raw::c_uint,
        analog_l: ::std::os::raw::c_uint,
        analog_r: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let err: u32 = unsafe { ::std::mem::transmute(err) };
            err as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let origin_unchecked: u32 = unsafe { ::std::mem::transmute(origin_unchecked) };
            origin_unchecked as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let start: u32 = unsafe { ::std::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let y: u32 = unsafe { ::std::mem::transmute(y) };
            y as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let x: u32 = unsafe { ::std::mem::transmute(x) };
            x as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let b: u32 = unsafe { ::std::mem::transmute(b) };
            b as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let a: u32 = unsafe { ::std::mem::transmute(a) };
            a as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let unused2: u32 = unsafe { ::std::mem::transmute(unused2) };
            unused2 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let l: u32 = unsafe { ::std::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let r: u32 = unsafe { ::std::mem::transmute(r) };
            r as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let z: u32 = unsafe { ::std::mem::transmute(z) };
            z as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let up: u32 = unsafe { ::std::mem::transmute(up) };
            up as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let down: u32 = unsafe { ::std::mem::transmute(down) };
            down as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let right: u32 = unsafe { ::std::mem::transmute(right) };
            right as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let left: u32 = unsafe { ::std::mem::transmute(left) };
            left as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let stick_x: u32 = unsafe { ::std::mem::transmute(stick_x) };
            stick_x as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let stick_y: u32 = unsafe { ::std::mem::transmute(stick_y) };
            stick_y as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let cstick_x: u32 = unsafe { ::std::mem::transmute(cstick_x) };
            cstick_x as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let cstick_y: u32 = unsafe { ::std::mem::transmute(cstick_y) };
            cstick_y as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let analog_l: u32 = unsafe { ::std::mem::transmute(analog_l) };
            analog_l as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let analog_r: u32 = unsafe { ::std::mem::transmute(analog_r) };
            analog_r as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SI_condat_gc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SI_condat_gc__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(SI_condat_gc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SI_condat_gc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SI_condat_gc__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_SI_condat_gc() {
    assert_eq!(
        ::std::mem::size_of::<SI_condat_gc>(),
        8usize,
        concat!("Size of: ", stringify!(SI_condat_gc))
    );
    assert_eq!(
        ::std::mem::align_of::<SI_condat_gc>(),
        8usize,
        concat!("Alignment of ", stringify!(SI_condat_gc))
    );
}
#[doc = " @brief SI GameCube controller data.\n\n Data structure for Joybus response to `0x40` (Read GC controller state) command."]
pub type _SI_condat_gc = SI_condat_gc;
#[doc = " @brief SI GameCube controller origin data.\n\n Data structure for Joybus response to `0x41` (Read GC controller origin) command."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SI_origdat_gc {
    pub data: SI_condat_gc,
    pub deadzone0: u8,
    pub deadzone1: u8,
}
#[test]
fn bindgen_test_layout_SI_origdat_gc() {
    const UNINIT: ::std::mem::MaybeUninit<SI_origdat_gc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SI_origdat_gc>(),
        16usize,
        concat!("Size of: ", stringify!(SI_origdat_gc))
    );
    assert_eq!(
        ::std::mem::align_of::<SI_origdat_gc>(),
        8usize,
        concat!("Alignment of ", stringify!(SI_origdat_gc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SI_origdat_gc),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deadzone0) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SI_origdat_gc),
            "::",
            stringify!(deadzone0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deadzone1) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(SI_origdat_gc),
            "::",
            stringify!(deadzone1)
        )
    );
}
#[doc = " @brief SI controller data for all controller ports.\n\n When reading N64 controller state, only the `c` member array will be populated.\n When reading GC controller state, only the `gc` member array will be populated."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct controller_data {
    #[doc = " @brief Array of N64 controller state for each controller port."]
    pub c: [SI_condat; 4usize],
    #[doc = " @brief Array of GameCube controller state for each controller port."]
    pub gc: [SI_condat_gc; 4usize],
}
#[test]
fn bindgen_test_layout_controller_data() {
    const UNINIT: ::std::mem::MaybeUninit<controller_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<controller_data>(),
        64usize,
        concat!("Size of: ", stringify!(controller_data))
    );
    assert_eq!(
        ::std::mem::align_of::<controller_data>(),
        8usize,
        concat!("Alignment of ", stringify!(controller_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(controller_data),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(controller_data),
            "::",
            stringify!(gc)
        )
    );
}
#[doc = " @brief SI controller data for all controller ports.\n\n When reading N64 controller state, only the `c` member array will be populated.\n When reading GC controller state, only the `gc` member array will be populated."]
pub type SI_controllers_state_t = controller_data;
#[doc = " @brief SI GameCube controller origin data for all controller ports."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct controller_origin_data {
    #[doc = " @brief Array of GameCube controller origin data for each controller port."]
    pub gc: [SI_origdat_gc; 4usize],
}
#[test]
fn bindgen_test_layout_controller_origin_data() {
    const UNINIT: ::std::mem::MaybeUninit<controller_origin_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<controller_origin_data>(),
        64usize,
        concat!("Size of: ", stringify!(controller_origin_data))
    );
    assert_eq!(
        ::std::mem::align_of::<controller_origin_data>(),
        8usize,
        concat!("Alignment of ", stringify!(controller_origin_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(controller_origin_data),
            "::",
            stringify!(gc)
        )
    );
}
#[doc = " @brief SI GameCube controller origin data for all controller ports."]
pub type SI_controllers_origin_t = controller_origin_data;
extern "C" {
    pub fn controller_init();
}
extern "C" {
    pub fn controller_read(data: *mut controller_data);
}
extern "C" {
    pub fn controller_read_gc(data: *mut controller_data, rumble: *const u8);
}
extern "C" {
    pub fn controller_read_gc_origin(data: *mut controller_origin_data);
}
extern "C" {
    pub fn get_controllers_present() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_accessories_present(data: *mut controller_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn controller_scan();
}
extern "C" {
    pub fn get_keys_down() -> controller_data;
}
extern "C" {
    pub fn get_keys_up() -> controller_data;
}
extern "C" {
    pub fn get_keys_held() -> controller_data;
}
extern "C" {
    pub fn get_keys_pressed() -> controller_data;
}
extern "C" {
    pub fn get_dpad_direction(controller: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_mempak_address(
        controller: ::std::os::raw::c_int,
        address: u16,
        data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write_mempak_address(
        controller: ::std::os::raw::c_int,
        address: u16,
        data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn identify_accessory(controller: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rumble_start(controller: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rumble_stop(controller: ::std::os::raw::c_int);
}
extern "C" {
    pub fn execute_raw_command(
        controller: ::std::os::raw::c_int,
        command: ::std::os::raw::c_int,
        bytesout: ::std::os::raw::c_int,
        bytesin: ::std::os::raw::c_int,
        out: *mut ::std::os::raw::c_uchar,
        in_: *mut ::std::os::raw::c_uchar,
    );
}
#[doc = " @brief Structure for storing RTC time data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtc_time_t {
    #[doc = " @brief Year. [1900-20XX]"]
    pub year: u16,
    #[doc = " @brief Month. [0-11]"]
    pub month: u8,
    #[doc = " @brief Day of month. [1-31]"]
    pub day: u8,
    #[doc = " @brief Hours. [0-23]"]
    pub hour: u8,
    #[doc = " @brief Minutes. [0-59]"]
    pub min: u8,
    #[doc = " @brief Seconds. [0-59]"]
    pub sec: u8,
    #[doc = " @brief Day of week. [0-6] (Sun-Sat)"]
    pub week_day: u8,
}
#[test]
fn bindgen_test_layout_rtc_time_t() {
    const UNINIT: ::std::mem::MaybeUninit<rtc_time_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rtc_time_t>(),
        8usize,
        concat!("Size of: ", stringify!(rtc_time_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rtc_time_t>(),
        2usize,
        concat!("Alignment of ", stringify!(rtc_time_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rtc_time_t),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rtc_time_t),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rtc_time_t),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rtc_time_t),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rtc_time_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rtc_time_t),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).week_day) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rtc_time_t),
            "::",
            stringify!(week_day)
        )
    );
}
extern "C" {
    pub fn rtc_init() -> bool;
}
extern "C" {
    pub fn rtc_close();
}
extern "C" {
    pub fn rtc_is_writable() -> bool;
}
extern "C" {
    pub fn rtc_get(rtc_time: *mut rtc_time_t) -> bool;
}
extern "C" {
    pub fn rtc_set(rtc_time: *mut rtc_time_t) -> bool;
}
extern "C" {
    pub fn rtc_normalize_time(rtc_time: *mut rtc_time_t);
}
#[doc = " @brief Structure representing a save entry in a mempak"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct entry_structure {
    #[doc = " @brief Vendor ID"]
    pub vendor: u32,
    #[doc = " @brief Game ID"]
    pub game_id: u16,
    #[doc = " @brief Inode pointer"]
    pub inode: u16,
    #[doc = " @brief Intended region"]
    pub region: u8,
    #[doc = " @brief Number of blocks used by this entry.\n @see MEMPAK_BLOCK_SIZE"]
    pub blocks: u8,
    #[doc = " @brief Validity of this entry."]
    pub valid: u8,
    #[doc = " @brief ID of this entry"]
    pub entry_id: u8,
    #[doc = " @brief Name of this entry\n\n The complete list of valid ASCII characters in a note name is:\n\n <pre>\n ABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#`*+,-./:=?\\@\n </pre>\n\n The space character is also allowed.  Any other character will be\n converted to a space before writing to the mempak."]
    pub name: [::std::os::raw::c_char; 19usize],
}
#[test]
fn bindgen_test_layout_entry_structure() {
    const UNINIT: ::std::mem::MaybeUninit<entry_structure> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<entry_structure>(),
        32usize,
        concat!("Size of: ", stringify!(entry_structure))
    );
    assert_eq!(
        ::std::mem::align_of::<entry_structure>(),
        4usize,
        concat!("Alignment of ", stringify!(entry_structure))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_structure),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).game_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_structure),
            "::",
            stringify!(game_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_structure),
            "::",
            stringify!(inode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).region) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_structure),
            "::",
            stringify!(region)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blocks) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_structure),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_structure),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_id) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_structure),
            "::",
            stringify!(entry_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_structure),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " @brief Structure representing a save entry in a mempak"]
pub type entry_structure_t = entry_structure;
extern "C" {
    pub fn read_mempak_sector(
        controller: ::std::os::raw::c_int,
        sector: ::std::os::raw::c_int,
        sector_data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write_mempak_sector(
        controller: ::std::os::raw::c_int,
        sector: ::std::os::raw::c_int,
        sector_data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn validate_mempak(controller: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_mempak_free_space(controller: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_mempak_entry(
        controller: ::std::os::raw::c_int,
        entry: ::std::os::raw::c_int,
        entry_data: *mut entry_structure_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn format_mempak(controller: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_mempak_entry_data(
        controller: ::std::os::raw::c_int,
        entry: *mut entry_structure_t,
        data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write_mempak_entry_data(
        controller: ::std::os::raw::c_int,
        entry: *mut entry_structure_t,
        data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn delete_mempak_entry(
        controller: ::std::os::raw::c_int,
        entry: *mut entry_structure_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief ROM only (32 KiB ROM)"]
pub const gb_cart_type_t_GB_ROM_ONLY: gb_cart_type_t = 0;
#[doc = " @brief MBC1 (max 2 MiB ROM)"]
pub const gb_cart_type_t_GB_MBC1: gb_cart_type_t = 1;
#[doc = " @brief MBC1 (max 2 MiB ROM) + RAM (32 KiB)"]
pub const gb_cart_type_t_GB_MBC1_RAM: gb_cart_type_t = 2;
#[doc = " @brief MBC1 (max 2 MiB ROM) + RAM (32 KiB) + Battery"]
pub const gb_cart_type_t_GB_MBC1_RAM_BATTERY: gb_cart_type_t = 3;
#[doc = " @brief MBC2 (max 256 KiB ROM; 512x4 bits RAM built-in)"]
pub const gb_cart_type_t_GB_MBC2: gb_cart_type_t = 5;
#[doc = " @brief MBC2 (max 256 KiB ROM; 512x4 bits RAM built-in) + Battery"]
pub const gb_cart_type_t_GB_MBC2_BATTERY: gb_cart_type_t = 6;
#[doc = " @brief ROM (32 KiB) + RAM (max 8 KiB)"]
pub const gb_cart_type_t_GB_ROM_RAM: gb_cart_type_t = 8;
#[doc = " @brief ROM (32 KiB) + RAM (max 8 KiB) + Battery"]
pub const gb_cart_type_t_GB_ROM_RAM_BATTERY: gb_cart_type_t = 9;
#[doc = " @brief MMM01 (\"Meta-mapper\")"]
pub const gb_cart_type_t_GB_MMM01: gb_cart_type_t = 11;
#[doc = " @brief MMM01 (\"Meta-mapper\") + RAM"]
pub const gb_cart_type_t_GB_MMM01_RAM: gb_cart_type_t = 12;
#[doc = " @brief MMM01 (\"Meta-mapper\") + RAM + Battery"]
pub const gb_cart_type_t_GB_MMM01_RAM_BATTERY: gb_cart_type_t = 13;
#[doc = " @brief MBC3 (max 2 MiB ROM)"]
pub const gb_cart_type_t_GB_MBC3: gb_cart_type_t = 17;
#[doc = " @brief MBC3 (max 2 MiB ROM) + RAM (64 KiB)"]
pub const gb_cart_type_t_GB_MBC3_RAM: gb_cart_type_t = 18;
#[doc = " @brief MBC3 (max 2 MiB ROM) + RAM (64 KiB) + Battery"]
pub const gb_cart_type_t_GB_MBC3_RAM_BATTERY: gb_cart_type_t = 19;
#[doc = " @brief MBC3 (max 2 MiB ROM) + Real-Time Clock + Battery"]
pub const gb_cart_type_t_GB_MBC3_TIMER_BATTERY: gb_cart_type_t = 15;
#[doc = " @brief MBC3 (max 2 MiB ROM) + Real-Time Clock + RAM (64 KiB) + Battery"]
pub const gb_cart_type_t_GB_MBC3_TIMER_RAM_BATTERY: gb_cart_type_t = 16;
#[doc = " @brief MBC5 (max 8 MiB ROM)"]
pub const gb_cart_type_t_GB_MBC5: gb_cart_type_t = 25;
#[doc = " @brief MBC5 (max 8 MiB ROM) + RAM (128 KiB)"]
pub const gb_cart_type_t_GB_MBC5_RAM: gb_cart_type_t = 26;
#[doc = " @brief MBC5 (max 8 MiB ROM) + RAM (128 KiB) + Battery"]
pub const gb_cart_type_t_GB_MBC5_RAM_BATTERY: gb_cart_type_t = 27;
#[doc = " @brief MBC5 (max 8 MiB ROM) + Rumble"]
pub const gb_cart_type_t_GB_MBC5_RUMBLE: gb_cart_type_t = 28;
#[doc = " @brief MBC5 (max 8 MiB ROM) + Rumble + RAM (128 KiB)"]
pub const gb_cart_type_t_GB_MBC5_RUMBLE_RAM: gb_cart_type_t = 29;
#[doc = " @brief MBC5 (max 8 MiB ROM) + Rumble + RAM (128 KiB) + Battery"]
pub const gb_cart_type_t_GB_MBC5_RUMBLE_RAM_BATTERY: gb_cart_type_t = 30;
#[doc = " @brief MBC6"]
pub const gb_cart_type_t_GB_MBC6: gb_cart_type_t = 32;
#[doc = " @brief MBC7 + Tilt Sensor + Rumble + RAM + Battery"]
pub const gb_cart_type_t_GB_MBC7_SENSOR_RUMBLE_RAM_BATTERY: gb_cart_type_t = 34;
#[doc = " @brief Game Boy Camera"]
pub const gb_cart_type_t_GB_POCKET_CAMERA: gb_cart_type_t = 252;
#[doc = " @brief Bandai TAMA5"]
pub const gb_cart_type_t_GB_BANDAI_TAMA5: gb_cart_type_t = 253;
#[doc = " @brief Hudson HuC3"]
pub const gb_cart_type_t_GB_HUC3: gb_cart_type_t = 254;
#[doc = " @brief Hudson HuC1 + RAM + Battery"]
pub const gb_cart_type_t_GB_HUC1_RAM_BATTERY: gb_cart_type_t = 255;
#[doc = " @brief Game Boy cartridge types.\n\n Describes the Memory Bank Controller and other hardware on the cartridge."]
pub type gb_cart_type_t = ::std::os::raw::c_uchar;
#[doc = " @brief ROM size: 32 KiB (no banks)"]
pub const gb_cart_rom_size_t_GB_ROM_32KB: gb_cart_rom_size_t = 0;
#[doc = " @brief ROM size: 64 KiB (4 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_64KB: gb_cart_rom_size_t = 1;
#[doc = " @brief ROM size: 128 KiB (8 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_128KB: gb_cart_rom_size_t = 2;
#[doc = " @brief ROM size: 256 KiB (16 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_256KB: gb_cart_rom_size_t = 3;
#[doc = " @brief ROM size: 512 KiB (32 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_512KB: gb_cart_rom_size_t = 4;
#[doc = " @brief ROM size: 1 MiB (64 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_1MB: gb_cart_rom_size_t = 5;
#[doc = " @brief ROM size: 2 MiB (128 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_2MB: gb_cart_rom_size_t = 6;
#[doc = " @brief ROM size: 4 MiB (256 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_4MB: gb_cart_rom_size_t = 7;
#[doc = " @brief ROM size: 8 MiB (512 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_8MB: gb_cart_rom_size_t = 8;
#[doc = " @brief ROM size: 1.125 MiB (72 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_1152KB: gb_cart_rom_size_t = 82;
#[doc = " @brief ROM size: 1.25 MiB (80 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_1280KB: gb_cart_rom_size_t = 83;
#[doc = " @brief ROM size: 1.5 MiB (96 banks)"]
pub const gb_cart_rom_size_t_GB_ROM_1536KB: gb_cart_rom_size_t = 84;
#[doc = " @brief Game Boy cartridge ROM size types.\n\n Describes how many ROM banks are available on the cartridge."]
pub type gb_cart_rom_size_t = ::std::os::raw::c_uchar;
#[doc = " @brief RAM not available"]
pub const gb_cart_ram_size_t_GB_RAM_NONE: gb_cart_ram_size_t = 0;
#[doc = " @brief RAM size: 2 KiB (no banks)"]
pub const gb_cart_ram_size_t_GB_RAM_2KB: gb_cart_ram_size_t = 1;
#[doc = " @brief RAM size: 8 KiB (no banks)"]
pub const gb_cart_ram_size_t_GB_RAM_8KB: gb_cart_ram_size_t = 2;
#[doc = " @brief RAM size: 32 KiB (4 banks)"]
pub const gb_cart_ram_size_t_GB_RAM_32KB: gb_cart_ram_size_t = 3;
#[doc = " @brief RAM size: 64 KiB (8 banks)"]
pub const gb_cart_ram_size_t_GB_RAM_64KB: gb_cart_ram_size_t = 5;
#[doc = " @brief RAM size: 128 KiB (16 banks)"]
pub const gb_cart_ram_size_t_GB_RAM_128KB: gb_cart_ram_size_t = 4;
#[doc = " @brief Game Boy cartridge RAM size types.\n\n Describes how much SRAM is available on the cartridge."]
pub type gb_cart_ram_size_t = ::std::os::raw::c_uchar;
#[doc = " @brief Game Boy Color not supported.\n\n Cartridge has no special support for Game Boy Color and will run in\n original Game Boy mode. This is typically a grey Game Boy Game Pak\n with a notch in the corner."]
pub const gbc_support_type_GBC_NOT_SUPPORTED: gbc_support_type = 0;
#[doc = " @brief Game Boy Color enhanced.\n\n Cartridge has special support for Game Boy Color, but still works on\n original Game Boy. This is typically a black Game Boy Game Pak with\n a notch in the corner."]
pub const gbc_support_type_GBC_DMG_SUPPORTED: gbc_support_type = 128;
#[doc = " @brief Game Boy Color required.\n\n Cartridge has special support for Game Boy Color and does not work on\n original Game Boy. This is typically a black Game Boy Game Pak that\n does not have a notch in the corner, which physically prevents it\n from being played on original Game Boy."]
pub const gbc_support_type_GBC_ONLY_SUPPORTED: gbc_support_type = 192;
#[doc = " @brief Game Boy Color cartridge compatibility values.\n\n Found in the cartridge ROM header; describes whether the game should boot\n into CGB mode or monochrome \"Non CGB\" compatibility mode."]
pub type gbc_support_type = ::std::os::raw::c_uchar;
#[doc = " @brief Not enhanced for Super Game Boy."]
pub const sgb_support_type_SGB_NOT_ENHANCED: sgb_support_type = 0;
#[doc = " @brief Enhanced for Super Game Boy."]
pub const sgb_support_type_SGB_ENHANCED: sgb_support_type = 3;
#[doc = " @brief Super Game Boy cartridge compatibility values.\n\n Found in the cartridge ROM header; describes whether the game has\n special enhancements for the Super Game Boy."]
pub type sgb_support_type = ::std::os::raw::c_uchar;
#[doc = " @brief \"Old\" Game Boy Color cartridge ROM header title structure.\n\n When the Game Boy Color was first introduced, games could use up to\n 15 characters for the title, and 1 byte to signal CGB compatibility."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct old_gbc_title {
    #[doc = " @brief Game title in ASCII."]
    pub title: [u8; 15usize],
    #[doc = " @brief Game Boy Color support."]
    pub gbc_support: gbc_support_type,
}
#[test]
fn bindgen_test_layout_old_gbc_title() {
    const UNINIT: ::std::mem::MaybeUninit<old_gbc_title> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<old_gbc_title>(),
        16usize,
        concat!("Size of: ", stringify!(old_gbc_title))
    );
    assert_eq!(
        ::std::mem::align_of::<old_gbc_title>(),
        1usize,
        concat!("Alignment of ", stringify!(old_gbc_title))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).title) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(old_gbc_title),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gbc_support) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(old_gbc_title),
            "::",
            stringify!(gbc_support)
        )
    );
}
#[doc = " @brief \"New\" Game Boy Color cartridge ROM header title structure.\n\n Shortly after the Game Boy Color launched, games were limited to\n 11 characters for the title, 4 bytes for a manufacturer code, and\n 1 byte for CGB compatibility."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct new_gbc_title {
    #[doc = " @brief Game title in ASCII."]
    pub title: [u8; 11usize],
    #[doc = " @brief Manufacturer identifier."]
    pub manufacturer_code: [u8; 4usize],
    #[doc = " @brief Game Boy Color support."]
    pub gbc_support: gbc_support_type,
}
#[test]
fn bindgen_test_layout_new_gbc_title() {
    const UNINIT: ::std::mem::MaybeUninit<new_gbc_title> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<new_gbc_title>(),
        16usize,
        concat!("Size of: ", stringify!(new_gbc_title))
    );
    assert_eq!(
        ::std::mem::align_of::<new_gbc_title>(),
        1usize,
        concat!("Alignment of ", stringify!(new_gbc_title))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).title) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(new_gbc_title),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manufacturer_code) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(new_gbc_title),
            "::",
            stringify!(manufacturer_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gbc_support) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(new_gbc_title),
            "::",
            stringify!(gbc_support)
        )
    );
}
#[doc = " @brief Game Boy cartridge ROM header structure.\n\n Data located at $0100-014F in each Game Boy cartridge ROM."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gameboy_cartridge_header {
    #[doc = " @brief Z80 instructions to boot the main program."]
    pub entry_point: [u8; 4usize],
    #[doc = " @brief Bitmap image data for the boot logo."]
    pub logo: [u8; 48usize],
    pub __bindgen_anon_1: gameboy_cartridge_header__bindgen_ty_1,
    #[doc = " @brief \"New\" publisher identifier."]
    pub new_licensee_code: u16,
    #[doc = " @brief Super Game Boy support."]
    pub is_sgb_supported: sgb_support_type,
    #[doc = " @brief Cartridge type."]
    pub cartridge_type: gb_cart_type_t,
    #[doc = " @brief ROM size identifier."]
    pub rom_size_code: gb_cart_rom_size_t,
    #[doc = " @brief RAM size identifier."]
    pub ram_size_code: gb_cart_ram_size_t,
    #[doc = " @brief Japan-only identifier."]
    pub destination_code: u8,
    #[doc = " @brief \"Old\" publisher identifier."]
    pub old_licensee_code: u8,
    #[doc = " @brief Version number of the game."]
    pub version_number: u8,
    #[doc = " @brief Checksum of cartridge ROM header."]
    pub header_checksum: u8,
    #[doc = " @brief Checksum of entire cartridge ROM."]
    pub global_checksum: u16,
    #[doc = " @brief Padding."]
    pub overflow: [u8; 16usize],
}
#[doc = " @brief Union of possible structures for the game title bytes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union gameboy_cartridge_header__bindgen_ty_1 {
    #[doc = " @brief Game title in ASCII."]
    pub title: [u8; 16usize],
    #[doc = " @brief \"Old\" Game Boy Color title structure."]
    pub old_title: old_gbc_title,
    #[doc = " @brief \"New\" Game Boy Color title structure."]
    pub new_title: new_gbc_title,
}
#[test]
fn bindgen_test_layout_gameboy_cartridge_header__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<gameboy_cartridge_header__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gameboy_cartridge_header__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(gameboy_cartridge_header__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gameboy_cartridge_header__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(gameboy_cartridge_header__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).title) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header__bindgen_ty_1),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).old_title) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header__bindgen_ty_1),
            "::",
            stringify!(old_title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_title) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header__bindgen_ty_1),
            "::",
            stringify!(new_title)
        )
    );
}
#[test]
fn bindgen_test_layout_gameboy_cartridge_header() {
    const UNINIT: ::std::mem::MaybeUninit<gameboy_cartridge_header> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gameboy_cartridge_header>(),
        96usize,
        concat!("Size of: ", stringify!(gameboy_cartridge_header))
    );
    assert_eq!(
        ::std::mem::align_of::<gameboy_cartridge_header>(),
        2usize,
        concat!("Alignment of ", stringify!(gameboy_cartridge_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(entry_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(logo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_licensee_code) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(new_licensee_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_sgb_supported) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(is_sgb_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cartridge_type) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(cartridge_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rom_size_code) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(rom_size_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ram_size_code) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(ram_size_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_code) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(destination_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).old_licensee_code) as usize - ptr as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(old_licensee_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_number) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(version_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_checksum) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(header_checksum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_checksum) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(global_checksum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(gameboy_cartridge_header),
            "::",
            stringify!(overflow)
        )
    );
}
extern "C" {
    pub fn tpak_init(controller: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tpak_set_value(
        controller: ::std::os::raw::c_int,
        address: u16,
        value: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tpak_set_bank(
        controller: ::std::os::raw::c_int,
        bank: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tpak_set_power(
        controller: ::std::os::raw::c_int,
        power_state: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tpak_set_access(
        controller: ::std::os::raw::c_int,
        access_state: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tpak_get_status(controller: ::std::os::raw::c_int) -> u8;
}
extern "C" {
    pub fn tpak_get_cartridge_header(
        controller: ::std::os::raw::c_int,
        header: *mut gameboy_cartridge_header,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tpak_check_header(header: *mut gameboy_cartridge_header) -> bool;
}
extern "C" {
    pub fn tpak_write(
        controller: ::std::os::raw::c_int,
        address: u16,
        data: *mut u8,
        size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tpak_read(
        controller: ::std::os::raw::c_int,
        address: u16,
        buffer: *mut u8,
        size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dma_write_raw_async(
        ram_address: *const ::std::os::raw::c_void,
        pi_address: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn dma_write(
        ram_address: *const ::std::os::raw::c_void,
        pi_address: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn dma_read_raw_async(
        ram_address: *mut ::std::os::raw::c_void,
        pi_address: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn dma_read_async(
        ram_address: *mut ::std::os::raw::c_void,
        pi_address: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn dma_read(
        ram_address: *mut ::std::os::raw::c_void,
        pi_address: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn dma_wait();
}
extern "C" {
    pub fn io_read(pi_address: u32) -> u32;
}
extern "C" {
    pub fn io_write(pi_address: u32, data: u32);
}
extern "C" {
    pub fn io_accessible(pi_address: u32) -> bool;
}
extern "C" {
    pub fn dma_busy() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_init(base_fs_loc: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_chdir(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_dir_findfirst(
        path: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_dir_findnext(buf: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_open(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_read(
        buf: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        handle: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_seek(
        handle: u32,
        offset: ::std::os::raw::c_int,
        origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_tell(handle: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_close(handle: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_eof(handle: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_size(handle: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dfs_rom_addr(path: *const ::std::os::raw::c_char) -> u32;
}
#[doc = " @brief No EEPROM present"]
pub const eeprom_type_t_EEPROM_NONE: eeprom_type_t = 0;
#[doc = " @brief 4 kilobit (64-block) EEPROM present"]
pub const eeprom_type_t_EEPROM_4K: eeprom_type_t = 1;
#[doc = " @brief 16 kilobit (256-block) EEPROM present"]
pub const eeprom_type_t_EEPROM_16K: eeprom_type_t = 2;
#[doc = " @brief EEPROM Probe Values\n @see #eeprom_present"]
pub type eeprom_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn eeprom_present() -> eeprom_type_t;
}
extern "C" {
    pub fn eeprom_total_blocks() -> usize;
}
extern "C" {
    pub fn eeprom_read(block: u8, dest: *mut u8);
}
extern "C" {
    pub fn eeprom_write(block: u8, src: *const u8) -> u8;
}
extern "C" {
    pub fn eeprom_read_bytes(dest: *mut u8, start: usize, len: usize);
}
extern "C" {
    pub fn eeprom_write_bytes(src: *const u8, start: usize, len: usize);
}
#[doc = " @brief EEPROM filesystem configuration file entry\n @see #eepfs_init"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eepfs_entry_t {
    #[doc = " @brief File path.\n\n This cannot be NULL and must be a `\\0`-terminated string.\n\n There are no enforced limitations on directory structure\n or file naming conventions except that all paths within\n the filesystem must be unique and at least one character.\n\n A leading '/' is optional and will be ignored if set.\n\n The filesytem does not support entries for directories,\n nor does it support listing files in a given directory."]
    pub path: *const ::std::os::raw::c_char,
    #[doc = " @brief File size in bytes.\n\n In order to make the most use of limited EEPROM space,\n files should be (but are not required to be) aligned to the\n 8-byte block size. Unaligned bytes at the end of a file will\n be wasted as padding; files must start on a block boundary.\n\n The filesystem itself reserves the first block of EEPROM,\n so your total filesystem size cannot exceed the available\n EEPROM size minus 8 bytes (64 bits):\n\n * 4k EEPROM: 512 - 8 = 504 bytes (63 blocks) free.\n * 16k EEPROM: 2048 - 8 = 2040 bytes (255 blocks) free."]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_eepfs_entry_t() {
    const UNINIT: ::std::mem::MaybeUninit<eepfs_entry_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<eepfs_entry_t>(),
        16usize,
        concat!("Size of: ", stringify!(eepfs_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<eepfs_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(eepfs_entry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eepfs_entry_t),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eepfs_entry_t),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn eepfs_init(entries: *const eepfs_entry_t, count: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eepfs_close() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eepfs_read(
        path: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eepfs_write(
        path: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eepfs_erase(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eepfs_verify_signature() -> bool;
}
extern "C" {
    pub fn eepfs_wipe();
}
#[doc = " @brief Generic color structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct color_t {
    #[doc = " @brief Red component"]
    pub r: u8,
    #[doc = " @brief Green component"]
    pub g: u8,
    #[doc = " @brief Blue component"]
    pub b: u8,
    #[doc = " @brief Alpha component"]
    pub a: u8,
}
#[test]
fn bindgen_test_layout_color_t() {
    const UNINIT: ::std::mem::MaybeUninit<color_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<color_t>(),
        4usize,
        concat!("Size of: ", stringify!(color_t))
    );
    assert_eq!(
        ::std::mem::align_of::<color_t>(),
        1usize,
        concat!("Alignment of ", stringify!(color_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(color_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(color_t),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(color_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(color_t),
            "::",
            stringify!(a)
        )
    );
}
#[doc = " @brief Sprite structure"]
#[repr(C)]
#[derive(Debug)]
pub struct sprite_t {
    #[doc = " @brief Width in pixels"]
    pub width: u16,
    #[doc = " @brief Height in pixels"]
    pub height: u16,
    #[doc = " @brief Bit depth expressed in bytes\n\n A 32 bit sprite would have a value of '4' here"]
    pub bitdepth: u8,
    #[doc = " @brief Sprite format\n @note Currently unused"]
    pub format: u8,
    #[doc = " @brief Number of horizontal slices for spritemaps"]
    pub hslices: u8,
    #[doc = " @brief Number of vertical slices for spritemaps"]
    pub vslices: u8,
    #[doc = " @brief Start of graphics data"]
    pub data: __IncompleteArrayField<u32>,
}
#[test]
fn bindgen_test_layout_sprite_t() {
    const UNINIT: ::std::mem::MaybeUninit<sprite_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sprite_t>(),
        8usize,
        concat!("Size of: ", stringify!(sprite_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sprite_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sprite_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sprite_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sprite_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitdepth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sprite_t),
            "::",
            stringify!(bitdepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sprite_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hslices) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sprite_t),
            "::",
            stringify!(hslices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vslices) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sprite_t),
            "::",
            stringify!(vslices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sprite_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn graphics_make_color(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        a: ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn graphics_convert_color(color: color_t) -> u32;
}
extern "C" {
    pub fn graphics_draw_pixel(
        surf: *mut surface_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: u32,
    );
}
extern "C" {
    pub fn graphics_draw_pixel_trans(
        surf: *mut surface_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: u32,
    );
}
extern "C" {
    pub fn graphics_draw_line(
        surf: *mut surface_t,
        x0: ::std::os::raw::c_int,
        y0: ::std::os::raw::c_int,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        c: u32,
    );
}
extern "C" {
    pub fn graphics_draw_line_trans(
        surf: *mut surface_t,
        x0: ::std::os::raw::c_int,
        y0: ::std::os::raw::c_int,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        c: u32,
    );
}
extern "C" {
    pub fn graphics_draw_box(
        surf: *mut surface_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color: u32,
    );
}
extern "C" {
    pub fn graphics_draw_box_trans(
        surf: *mut surface_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color: u32,
    );
}
extern "C" {
    pub fn graphics_fill_screen(surf: *mut surface_t, c: u32);
}
extern "C" {
    pub fn graphics_set_color(forecolor: u32, backcolor: u32);
}
extern "C" {
    pub fn graphics_set_default_font();
}
extern "C" {
    pub fn graphics_set_font_sprite(font: *mut sprite_t);
}
extern "C" {
    pub fn graphics_draw_character(
        surf: *mut surface_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn graphics_draw_text(
        surf: *mut surface_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn graphics_draw_sprite(
        surf: *mut surface_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        sprite: *mut sprite_t,
    );
}
extern "C" {
    pub fn graphics_draw_sprite_stride(
        surf: *mut surface_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        sprite: *mut sprite_t,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn graphics_draw_sprite_trans(
        surf: *mut surface_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        sprite: *mut sprite_t,
    );
}
extern "C" {
    pub fn graphics_draw_sprite_trans_stride(
        surf: *mut surface_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        sprite: *mut sprite_t,
        offset: ::std::os::raw::c_int,
    );
}
#[doc = " @brief Interrupt controller has not been initialized"]
pub const interrupt_state_t_INTERRUPTS_UNINITIALIZED: interrupt_state_t = 0;
#[doc = " @brief Interrupts are currently disabled"]
pub const interrupt_state_t_INTERRUPTS_DISABLED: interrupt_state_t = 1;
#[doc = " @brief Interrupts are currently enabled"]
pub const interrupt_state_t_INTERRUPTS_ENABLED: interrupt_state_t = 2;
#[doc = " @brief State of interrupts on the system"]
pub type interrupt_state_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @}"]
    pub fn register_AI_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn register_VI_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn register_PI_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn register_DP_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn register_SI_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn register_SP_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn register_TI_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn register_CART_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn unregister_AI_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn unregister_VI_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn unregister_PI_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn unregister_DP_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn unregister_SI_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn unregister_SP_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn unregister_TI_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn unregister_CART_handler(callback: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn set_AI_interrupt(active: ::std::os::raw::c_int);
}
extern "C" {
    pub fn set_VI_interrupt(active: ::std::os::raw::c_int, line: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn set_PI_interrupt(active: ::std::os::raw::c_int);
}
extern "C" {
    pub fn set_DP_interrupt(active: ::std::os::raw::c_int);
}
extern "C" {
    pub fn set_SI_interrupt(active: ::std::os::raw::c_int);
}
extern "C" {
    pub fn set_SP_interrupt(active: ::std::os::raw::c_int);
}
extern "C" {
    pub fn set_TI_interrupt(active: ::std::os::raw::c_int);
}
extern "C" {
    pub fn set_CART_interrupt(active: ::std::os::raw::c_int);
}
extern "C" {
    pub fn enable_interrupts();
}
extern "C" {
    pub fn disable_interrupts();
}
extern "C" {
    pub fn get_interrupts_state() -> interrupt_state_t;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
extern "C" {
    #[doc = " @brief Indicates whether we are running on a vanilla N64 or a iQue player"]
    pub static mut __bbplayer: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Symbol at the end of code, data, and sdata (set by the linker)"]
    pub static mut __rom_end: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn sys_bbplayer() -> bool;
}
extern "C" {
    pub fn sys_get_boot_cic() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sys_set_boot_cic(bc: ::std::os::raw::c_int);
}
extern "C" {
    pub fn wait_ticks(wait: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn wait_ms(wait_ms: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __data_cache_hit_invalidate(
        addr: *mut ::std::os::raw::c_void,
        length: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn data_cache_hit_writeback(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn data_cache_hit_writeback_invalidate(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn data_cache_index_writeback_invalidate(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn data_cache_writeback_invalidate_all();
}
extern "C" {
    pub fn inst_cache_hit_writeback(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn inst_cache_hit_invalidate(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn inst_cache_index_invalidate(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn inst_cache_invalidate_all();
}
extern "C" {
    pub fn get_memory_size() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_memory_expanded() -> bool;
}
extern "C" {
    pub fn malloc_uncached(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_uncached_aligned(
        align: ::std::os::raw::c_int,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free_uncached(buf: *mut ::std::os::raw::c_void);
}
#[doc = "< Video output is PAL"]
pub const tv_type_t_TV_PAL: tv_type_t = 0;
#[doc = "< Video output is NTSC"]
pub const tv_type_t_TV_NTSC: tv_type_t = 1;
#[doc = "< Video output is M-PAL"]
pub const tv_type_t_TV_MPAL: tv_type_t = 2;
#[doc = " @brief Type of TV video output"]
pub type tv_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn get_tv_type() -> tv_type_t;
}
#[doc = " @brief Disable texture mirroring"]
pub const mirror_t_MIRROR_DISABLED: mirror_t = 0;
#[doc = " @brief Enable texture mirroring on x axis"]
pub const mirror_t_MIRROR_X: mirror_t = 1;
#[doc = " @brief Enable texture mirroring on y axis"]
pub const mirror_t_MIRROR_Y: mirror_t = 2;
#[doc = " @brief Enable texture mirroring on both x & y axis"]
pub const mirror_t_MIRROR_XY: mirror_t = 3;
#[doc = " @brief Mirror settings for textures"]
pub type mirror_t = ::std::os::raw::c_uint;
#[doc = " @brief Wait for any operation to complete before causing a DP interrupt"]
pub const sync_t_SYNC_FULL: sync_t = 0;
#[doc = " @brief Sync the RDP pipeline"]
pub const sync_t_SYNC_PIPE: sync_t = 1;
#[doc = " @brief Block until all texture load operations are complete"]
pub const sync_t_SYNC_LOAD: sync_t = 2;
#[doc = " @brief Block until all tile operations are complete"]
pub const sync_t_SYNC_TILE: sync_t = 3;
#[doc = " @brief RDP sync operations"]
pub type sync_t = ::std::os::raw::c_uint;
#[doc = " @brief Textures are assumed to be pre-flushed"]
pub const flush_t_FLUSH_STRATEGY_NONE: flush_t = 0;
#[doc = " @brief Cache will be flushed on all incoming textures"]
pub const flush_t_FLUSH_STRATEGY_AUTOMATIC: flush_t = 1;
#[doc = " @brief Caching strategy for loaded textures"]
pub type flush_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn rdp_init();
}
extern "C" {
    pub fn rdp_attach(disp: *mut surface_t);
}
extern "C" {
    pub fn rdp_detach();
}
extern "C" {
    pub fn rdp_sync(sync: sync_t);
}
extern "C" {
    pub fn rdp_set_clipping(tx: u32, ty: u32, bx: u32, by: u32);
}
extern "C" {
    pub fn rdp_set_default_clipping();
}
extern "C" {
    pub fn rdp_enable_primitive_fill();
}
extern "C" {
    pub fn rdp_enable_blend_fill();
}
extern "C" {
    pub fn rdp_enable_texture_copy();
}
extern "C" {
    pub fn rdp_load_texture(
        texslot: u32,
        texloc: u32,
        mirror: mirror_t,
        sprite: *mut sprite_t,
    ) -> u32;
}
extern "C" {
    pub fn rdp_load_texture_stride(
        texslot: u32,
        texloc: u32,
        mirror: mirror_t,
        sprite: *mut sprite_t,
        offset: ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn rdp_draw_textured_rectangle(
        texslot: u32,
        tx: ::std::os::raw::c_int,
        ty: ::std::os::raw::c_int,
        bx: ::std::os::raw::c_int,
        by: ::std::os::raw::c_int,
        mirror: mirror_t,
    );
}
extern "C" {
    pub fn rdp_draw_textured_rectangle_scaled(
        texslot: u32,
        tx: ::std::os::raw::c_int,
        ty: ::std::os::raw::c_int,
        bx: ::std::os::raw::c_int,
        by: ::std::os::raw::c_int,
        x_scale: f64,
        y_scale: f64,
        mirror: mirror_t,
    );
}
extern "C" {
    pub fn rdp_draw_sprite(
        texslot: u32,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        mirror: mirror_t,
    );
}
extern "C" {
    pub fn rdp_draw_sprite_scaled(
        texslot: u32,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        x_scale: f64,
        y_scale: f64,
        mirror: mirror_t,
    );
}
extern "C" {
    pub fn rdp_set_primitive_color(color: u32);
}
extern "C" {
    pub fn rdp_set_blend_color(color: u32);
}
extern "C" {
    pub fn rdp_draw_filled_rectangle(
        tx: ::std::os::raw::c_int,
        ty: ::std::os::raw::c_int,
        bx: ::std::os::raw::c_int,
        by: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rdp_draw_filled_triangle(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32);
}
extern "C" {
    pub fn rdp_set_texture_flush(flush: flush_t);
}
extern "C" {
    pub fn rdp_close();
}
#[doc = " @brief Snapshot of the register status of the RSP.\n\n This structure is used in the crash handler."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rsp_snapshot_t {
    #[doc = "< General purpose registers"]
    pub gpr: [u32; 32usize],
    #[doc = "< Vector registers"]
    pub vpr: [[u16; 8usize]; 32usize],
    #[doc = "< Vector accumulator"]
    pub vaccum: [[u16; 8usize]; 3usize],
    #[doc = "< COP0 registers (note: reg 4 is SP_STATUS)"]
    pub cop0: [u32; 16usize],
    #[doc = "< COP2 control registers"]
    pub cop2: [u32; 3usize],
    #[doc = "< Program counter"]
    pub pc: u32,
    #[doc = "< Contents of DMEM"]
    pub dmem: [u8; 4096usize],
    #[doc = "< Contents of IMEM"]
    pub imem: [u8; 4096usize],
}
#[test]
fn bindgen_test_layout_rsp_snapshot_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsp_snapshot_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsp_snapshot_t>(),
        8960usize,
        concat!("Size of: ", stringify!(rsp_snapshot_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsp_snapshot_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsp_snapshot_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_snapshot_t),
            "::",
            stringify!(gpr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vpr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_snapshot_t),
            "::",
            stringify!(vpr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vaccum) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_snapshot_t),
            "::",
            stringify!(vaccum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cop0) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_snapshot_t),
            "::",
            stringify!(cop0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cop2) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_snapshot_t),
            "::",
            stringify!(cop2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_snapshot_t),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmem) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_snapshot_t),
            "::",
            stringify!(dmem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imem) as usize - ptr as usize },
        4864usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_snapshot_t),
            "::",
            stringify!(imem)
        )
    );
}
#[doc = " @brief RSP ucode definition.\n\n This small structure holds the text/data pointers to a RSP ucode program\n in RDRAM. It also contains the name (for the debugging purposes) and\n the initial PC (usually 0).\n\n If you're using libdragon's build system (n64.mk), use DEFINE_RSP_UCODE()\n to initialize one of these."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsp_ucode_t {
    #[doc = "< Pointer to the code segment"]
    pub code: *mut u8,
    #[doc = "< Pointer past the end of the code segment"]
    pub code_end: *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to the data segment"]
    pub data: *mut u8,
    #[doc = "< Pointer past the end of the data segment"]
    pub data_end: *mut ::std::os::raw::c_void,
    #[doc = "< Name of the ucode"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Initial RSP PC"]
    pub start_pc: u32,
    #[doc = " @brief Custom crash handler.\n\n If specified, this function is invoked when a RSP crash happens,\n while filling the information screen. It can be used to dump\n custom ucode-specific information.\n\n @note DO NOT ACCESS RSP hardware registers in the crash handler.\n       To dump information, access the state provided as argument\n       that contains a full snapshot of the RSP state at the point\n       of crash."]
    pub crash_handler: ::std::option::Option<unsafe extern "C" fn(state: *mut rsp_snapshot_t)>,
    #[doc = " @brief Custom assert handler.\n\n If specified, this function is invoked when a RSP crash caused\n by an assert is triggered. This function should display information\n related to the assert using `printf` (max 2 lines).\n\n Normally, the first line will be the assert message associated with\n the code (eg: \"Invalid buffer pointer\"), while the optional second line\n can contain a dump of a few important variables, maybe extracted from\n the register state (eg: \"bufptr=0x00000000 prevptr=0x8003F780\").\n The assert handler will now which registers to inspect to extract\n information, given the exact position of the assert in the code.\n\n @note The crash handler, if specified, is called for all crashes,\n including asserts. That is the correct place where dump information\n on the ucode state in general."]
    pub assert_handler:
        ::std::option::Option<unsafe extern "C" fn(state: *mut rsp_snapshot_t, assert_code: u16)>,
}
#[test]
fn bindgen_test_layout_rsp_ucode_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsp_ucode_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsp_ucode_t>(),
        64usize,
        concat!("Size of: ", stringify!(rsp_ucode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsp_ucode_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsp_ucode_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_ucode_t),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code_end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_ucode_t),
            "::",
            stringify!(code_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_ucode_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_ucode_t),
            "::",
            stringify!(data_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_ucode_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_pc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_ucode_t),
            "::",
            stringify!(start_pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crash_handler) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_ucode_t),
            "::",
            stringify!(crash_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).assert_handler) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rsp_ucode_t),
            "::",
            stringify!(assert_handler)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize the RSP subsytem."]
    pub fn rsp_init();
}
extern "C" {
    #[doc = " @brief Load a RSP ucode.\n\n This function allows to load a RSP ucode into the RSP internal memory.\n The function executes the transfer right away, so it is responsibility\n of the caller making sure that it's a good time to do it.\n\n The function internally keeps a pointer to the last loaded ucode. If the\n ucode passed is the same, it does nothing. This makes it easier to write\n code that optimistically switches between different ucodes, but without\n forcing transfers every time.\n\n @param[in]     ucode       Ucode to load into RSP"]
    pub fn rsp_load(ucode: *mut rsp_ucode_t);
}
extern "C" {
    #[doc = " @brief Run RSP ucode.\n\n This function starts running the RSP, and wait until the ucode is finished."]
    pub fn rsp_run();
}
extern "C" {
    #[doc = " @brief Wait until RSP has finished processing.\n\n This function will wait until the RSP is halted. It contains a fixed\n timeout of 500 ms, after which #rsp_crash is invoked to abort the program."]
    pub fn rsp_wait();
}
extern "C" {
    #[doc = " @brief Do a DMA transfer to load a piece of code into RSP IMEM.\n\n This is a lower-level function that actually executes a DMA transfer\n from RDRAM to IMEM. Prefer using #rsp_load instead.\n\n @note in order for this function to be interoperable with #rsp_load, it\n will reset the last loaded ucode cache.\n\n @param[in]     code          Pointer to buffer in RDRAM containing code.\n                              Must be aligned to 8 bytes.\n @param[in]     size          Size of the code to load. Must be a multiple of 8.\n @param[in]     imem_offset   Byte offset in IMEM where to load the code.\n                              Must be a multiple of 8."]
    pub fn rsp_load_code(
        code: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
        imem_offset: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief Do a DMA transfer to load a piece of data into RSP DMEM.\n\n This is a lower-level function that actually executes a DMA transfer\n from RDRAM to DMEM. Prefer using rsp_load instead.\n\n @param[in]     data          Pointer to buffer in RDRAM containing data.\n                              Must be aligned to 8 bytes.\n @param[in]     size          Size of the data to load. Must be a multiple of 8.\n @param[in]     dmem_offset   Offset in DMEM where to load the code.\n                              Must be a multiple of 8."]
    pub fn rsp_load_data(
        data: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
        dmem_offset: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief Do a DMA transfer to load a piece of code from RSP IMEM to RDRAM.\n\n This is a lower-level function that actually executes a DMA transfer\n from IMEM to RDRAM.\n\n @param[in]     code          Pointer to buffer in RDRAM where to write code.\n                              Must be aligned to 8 bytes.\n @param[in]     size          Size of the code to load. Must be a multiple of 8.\n @param[in]     imem_offset   Byte offset in IMEM where where the code will\n                              be loaded from. Must be a multiple of 8."]
    pub fn rsp_read_code(
        code: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
        imem_offset: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief Do a DMA transfer to load a piece of data from RSP DMEM to RDRAM.\n\n This is a lower-level function that actually executes a DMA transfer\n from DMEM to RDRAM.\n\n @param[in]     data          Pointer to buffer in RDRAM where to write data.\n                              Must be aligned to 8 bytes.\n @param[in]     size          Size of the data to load. Must be a multiple of 8.\n @param[in]     dmem_offset   Byte offset in IMEM where where the data will\n                              be loaded from. Must be a multiple of 8."]
    pub fn rsp_read_data(
        data: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
        dmem_offset: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @cond"]
    pub fn __rsp_crash(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
extern "C" {
    pub fn __rsp_check_assert(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
#[doc = " @brief Timer callback function without context"]
pub type timer_callback1_t =
    ::std::option::Option<unsafe extern "C" fn(ovfl: ::std::os::raw::c_int)>;
#[doc = " @brief Timer callback function with context"]
pub type timer_callback2_t = ::std::option::Option<
    unsafe extern "C" fn(ovfl: ::std::os::raw::c_int, ctx: *mut ::std::os::raw::c_void),
>;
#[doc = " @brief Timer structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timer_link {
    #[doc = " @brief Absolute ticks value at which the timer expires."]
    pub left: u32,
    #[doc = " @brief Ticks to set if continuous"]
    pub set: u32,
    #[doc = " @brief To correct for drift"]
    pub ovfl: ::std::os::raw::c_int,
    #[doc = " @brief Timer flags.  See #TF_ONE_SHOT, #TF_CONTINUOUS, and #TF_DISABLED"]
    pub flags: ::std::os::raw::c_int,
    pub __bindgen_anon_1: timer_link__bindgen_ty_1,
    #[doc = " @brief Callback context parameter"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " @brief Link to next timer"]
    pub next: *mut timer_link,
}
#[doc = " @brief Callback function to call when timer fires"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union timer_link__bindgen_ty_1 {
    pub callback: timer_callback1_t,
    pub callback_with_context: timer_callback2_t,
}
#[test]
fn bindgen_test_layout_timer_link__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<timer_link__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timer_link__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(timer_link__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<timer_link__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(timer_link__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_link__bindgen_ty_1),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_with_context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_link__bindgen_ty_1),
            "::",
            stringify!(callback_with_context)
        )
    );
}
#[test]
fn bindgen_test_layout_timer_link() {
    const UNINIT: ::std::mem::MaybeUninit<timer_link> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timer_link>(),
        40usize,
        concat!("Size of: ", stringify!(timer_link))
    );
    assert_eq!(
        ::std::mem::align_of::<timer_link>(),
        8usize,
        concat!("Alignment of ", stringify!(timer_link))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_link),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_link),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ovfl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_link),
            "::",
            stringify!(ovfl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_link),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_link),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_link),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " @brief Timer structure"]
pub type timer_link_t = timer_link;
extern "C" {
    pub fn timer_init();
}
extern "C" {
    pub fn timer_close();
}
extern "C" {
    pub fn timer_ticks() -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn new_timer(
        ticks: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        callback: timer_callback1_t,
    ) -> *mut timer_link_t;
}
extern "C" {
    pub fn new_timer_context(
        ticks: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        callback: timer_callback2_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut timer_link_t;
}
extern "C" {
    pub fn start_timer(
        timer: *mut timer_link_t,
        ticks: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        callback: timer_callback1_t,
    );
}
extern "C" {
    pub fn start_timer_context(
        timer: *mut timer_link_t,
        ticks: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        callback: timer_callback2_t,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn restart_timer(timer: *mut timer_link_t);
}
extern "C" {
    pub fn stop_timer(timer: *mut timer_link_t);
}
extern "C" {
    pub fn delete_timer(timer: *mut timer_link_t);
}
#[doc = " @brief Unknown exception"]
pub const EXCEPTION_TYPE_UNKNOWN: _bindgen_ty_1 = 0;
#[doc = " @brief Reset exception"]
pub const EXCEPTION_TYPE_RESET: _bindgen_ty_1 = 1;
#[doc = " @brief Critical exception"]
pub const EXCEPTION_TYPE_CRITICAL: _bindgen_ty_1 = 2;
#[doc = " @brief Exception types"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const exception_code_t_EXCEPTION_CODE_INTERRUPT: exception_code_t = 0;
pub const exception_code_t_EXCEPTION_CODE_TLB_MODIFICATION: exception_code_t = 1;
pub const exception_code_t_EXCEPTION_CODE_TLB_LOAD_I_MISS: exception_code_t = 2;
pub const exception_code_t_EXCEPTION_CODE_TLB_STORE_MISS: exception_code_t = 3;
pub const exception_code_t_EXCEPTION_CODE_LOAD_I_ADDRESS_ERROR: exception_code_t = 4;
pub const exception_code_t_EXCEPTION_CODE_STORE_ADDRESS_ERROR: exception_code_t = 5;
pub const exception_code_t_EXCEPTION_CODE_I_BUS_ERROR: exception_code_t = 6;
pub const exception_code_t_EXCEPTION_CODE_D_BUS_ERROR: exception_code_t = 7;
pub const exception_code_t_EXCEPTION_CODE_SYS_CALL: exception_code_t = 8;
pub const exception_code_t_EXCEPTION_CODE_BREAKPOINT: exception_code_t = 9;
pub const exception_code_t_EXCEPTION_CODE_RESERVED_INSTRUCTION: exception_code_t = 10;
pub const exception_code_t_EXCEPTION_CODE_COPROCESSOR_UNUSABLE: exception_code_t = 11;
pub const exception_code_t_EXCEPTION_CODE_ARITHMETIC_OVERFLOW: exception_code_t = 12;
pub const exception_code_t_EXCEPTION_CODE_TRAP: exception_code_t = 13;
pub const exception_code_t_EXCEPTION_CODE_FLOATING_POINT: exception_code_t = 15;
pub const exception_code_t_EXCEPTION_CODE_WATCH: exception_code_t = 23;
#[doc = " @brief Exception codes"]
pub type exception_code_t = ::std::os::raw::c_uint;
#[doc = " @brief Structure representing a register block\n\n DO NOT modify the order unless editing inthandler.S"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct reg_block_t {
    #[doc = " @brief General purpose registers 1-32"]
    pub gpr: [u64; 32usize],
    #[doc = " @brief HI"]
    pub hi: u64,
    #[doc = " @brief LO"]
    pub lo: u64,
    #[doc = " @brief SR"]
    pub sr: u32,
    #[doc = " @brief CR (NOTE: can't modify this from an exception handler)"]
    pub cr: u32,
    #[doc = " @brief represents EPC - COP0 register $14\n\n The coprocessor 0 (system control coprocessor - COP0) register $14 is the\n return from exception program counter. For asynchronous exceptions it points\n to the place to continue execution whereas for synchronous (caused by code)\n exceptions, point to the instruction causing the fault condition, which\n needs correction in the exception handler. This member is for reading/writing\n its value."]
    pub epc: u32,
    #[doc = " @brief FC31"]
    pub fc31: u32,
    #[doc = " @brief Floating point registers 1-32"]
    pub fpr: [u64; 32usize],
}
#[test]
fn bindgen_test_layout_reg_block_t() {
    const UNINIT: ::std::mem::MaybeUninit<reg_block_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<reg_block_t>(),
        544usize,
        concat!("Size of: ", stringify!(reg_block_t))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_block_t>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_block_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_block_t),
            "::",
            stringify!(gpr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_block_t),
            "::",
            stringify!(hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lo) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_block_t),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sr) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_block_t),
            "::",
            stringify!(sr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_block_t),
            "::",
            stringify!(cr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epc) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_block_t),
            "::",
            stringify!(epc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fc31) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_block_t),
            "::",
            stringify!(fc31)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpr) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_block_t),
            "::",
            stringify!(fpr)
        )
    );
}
#[doc = " @brief Structure representing an exception"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception_t {
    #[doc = " @brief Exception type\n @see #EXCEPTION_TYPE_RESET, #EXCEPTION_TYPE_CRITICAL"]
    pub type_: i32,
    #[doc = " @brief Underlying exception code"]
    pub code: exception_code_t,
    #[doc = " @brief String information of exception"]
    pub info: *const ::std::os::raw::c_char,
    #[doc = " @brief Registers at point of exception"]
    pub regs: *mut reg_block_t,
}
#[test]
fn bindgen_test_layout_exception_t() {
    const UNINIT: ::std::mem::MaybeUninit<exception_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exception_t>(),
        24usize,
        concat!("Size of: ", stringify!(exception_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exception_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exception_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_t),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_t),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_t),
            "::",
            stringify!(regs)
        )
    );
}
extern "C" {
    pub fn register_exception_handler(
        cb: ::std::option::Option<unsafe extern "C" fn(arg1: *mut exception_t)>,
    );
}
extern "C" {
    pub fn exception_default_handler(ex: *mut exception_t);
}
extern "C" {
    pub fn register_reset_handler(cb: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn exception_reset_time() -> u32;
}
#[doc = " @brief Directory entry structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dir_t {
    #[doc = " @brief The name of the directory entry"]
    pub d_name: [::std::os::raw::c_char; 256usize],
    #[doc = " @brief The type of the directory entry.  See #DT_REG and #DT_DIR."]
    pub d_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dir_t() {
    const UNINIT: ::std::mem::MaybeUninit<dir_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dir_t>(),
        260usize,
        concat!("Size of: ", stringify!(dir_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dir_t>(),
        4usize,
        concat!("Alignment of ", stringify!(dir_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dir_t),
            "::",
            stringify!(d_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(dir_t),
            "::",
            stringify!(d_type)
        )
    );
}
extern "C" {
    #[doc = " @}"]
    pub fn dir_findfirst(
        path: *const ::std::os::raw::c_char,
        dir: *mut dir_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dir_findnext(
        path: *const ::std::os::raw::c_char,
        dir: *mut dir_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief A waveform that can be played back through the mixer.\n\n waveform_t represents a waveform that can be played back by the mixer.\n A waveform_t does not hold the actual samples because most real-world use\n cases do not keep all samples in memory, but rather load them and/or\n decompress them in real-time while the playback is happening.\n So waveform_t instead should be thought of as the generator of a\n waveform.\n\n To create a waveform, use one of waveform implementations such as wav64.\n Waveform implementations are in charge of generating the samples by actually\n implementing an audio format like VADPCM or MPEG-2.\n\n Waveforms can produce samples as 8-bit or 16-bit. Samples must always be\n signed. Stereo waveforms (interleaved samples) are supported: when used\n with #mixer_ch_play, they will use automatically two channels (the specified\n one and the following)."]
pub type waveform_t = waveform_s;
#[doc = " samplebuffer_t is a circular buffer of samples. It is used by the mixer\n to store and cache the samples required for playback on each channel.\n The mixer creates a sample buffer for each initialized channel. The size\n of the buffers is calculated for optimal playback, and might grow depending\n on channel usage (what waveforms are played on each channel).\n\n The mixer follows a \"pull\" architecture. During mixer_poll, it will call\n samplebuffer_get() to extract samples from the buffer. If the required\n samples are not available, the sample buffer will callback the waveform\n decoder to produce more samples, through the WaveformRead API. The\n waveform read function will push samples into the buffer via samplebuffer_append,\n so that they become available for the mixer. The decoder can be configured\n with samplebuffer_set_decoder.\n\n The current implementation of samplebuffer does not achieve full zero copy,\n because when the buffer is full, it is flushed and samples that need to\n be preserved (that is, already in the buffer but not yet played back) are\n copied back at the beginning of the buffer with the CPU. This limitation\n exists because the RSP ucode (rsp_audio.S) isn't currently able to \"wrap around\"\n in the sample buffer. In future, this limitation could be lifted to achieve\n full zero copy.\n\n The sample buffer tries to always stay 8-byte aligned to simplify operations\n of decoders that might need to use DMA transfers (either PI DMA or RSP DMA).\n To guarantee this property, #WaveformRead must collaborate by decoding\n the requested number of samples. If WaveformRead decodes a different\n number of samples, the alignment might be lost. Moreover, it always guarantees\n that the buffer has the same 2-byte phase of the waveforms (that is, odd\n samples of the waveforms are stored at odd addresses in memory); this is\n the minimal property required by #dma_read (libdragon's optimized PI DMA\n transfer for unaligned addresses).\n\n In general, the sample buffer assumes that the contained data is committed\n to physical memory, not just CPU cache. It is responsibility of the client\n to flush DMA cache (via data_cache_writeback) if samples are written\n via CPU."]
pub type samplebuffer_t = samplebuffer_s;
extern "C" {
    #[doc = " @brief Initialize the mixer\n\n The mixer must be initialized after the audio subsystem (audio_init).\n The number of channels specified is the maximum number of channels\n used by the application. Specifying a higher number means using\n more memory as the mixer will allocate one sample buffer per channel,\n but it does not affect performance (which correlates to the\n actual number of simultaneously playing channels).\n\n @param[in]    num_channels   Number of channels to initialize."]
    pub fn mixer_init(num_channels: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Deinitialize the mixer."]
    pub fn mixer_close();
}
extern "C" {
    #[doc = " @brief Set master volume.\n\n This is a global attenuation factor (range [0..1]) that will be applied\n to all channels and simplify implementing a global volume control.\n\n @param[in]    vol            Master volume (range [0..1])"]
    pub fn mixer_set_vol(vol: f32);
}
extern "C" {
    #[doc = " @brief Set channel volume (as left/right).\n\n Configure channel volume for the specified channel, specifying two values:\n one for the left output and one for the right output.\n\n The volume is an attenuation (no amplification is performed).\n Valid volume range in [0..1], where 0 is silence and 1 is original\n channel sample volume (no attenuation performed).\n\n Notice that it's perfectly valid to set left/right volumes even if the\n channel itself will play a mono waveforms, as it allows to balance a mono\n sample between the two final output channels.\n\n @param[in]   ch              Channel index\n @param[in]   lvol            Left volume (range [0..1])\n @param[in]   rvol            Right volume (range [0..1])"]
    pub fn mixer_ch_set_vol(ch: ::std::os::raw::c_int, lvol: f32, rvol: f32);
}
extern "C" {
    #[doc = " @brief Set channel volume (as volume and panning).\n\n Configure the left and right channel volumes for the specified channel,\n Using a central volume value and a panning value to specify left/right\n balance.\n\n Valid volume range in [0..1], where 0 is silence and 1 is maximum\n volume (no attenuation).\n\n Valid panning range is [0..1] where 0 is 100% left, and 1 is 100% right.\n\n Notice that panning 0.5 balance the sound but causes an attenuation of 50%.\n\n @param[in]   ch              Channel index\n @param[in]   vol             Central volume (range [0..1])\n @param[in]   pan             Panning (range [0..1], center is 0.5)"]
    pub fn mixer_ch_set_vol_pan(ch: ::std::os::raw::c_int, vol: f32, pan: f32);
}
extern "C" {
    #[doc = " @brief Set channel volume with Dolby Pro Logic II encoding.\n\n Configure the volumes of the specified channel according to the Dolby Pro\n Logic II matrix encoding. This allows to encode samples with a virtual surround\n system, that can be decoded with a Dolby 5.1 compatible equipment.\n\n The function accepts the volumes configured for the 5 channels: front left,\n front right, center, surround left, surround right. These values can be\n calculated from a 3D scene\n\n @param[in]   ch              Channel index\n @param[in]   fl              Front left volume (range [0..1])\n @param[in]   fr              Front right volume (range [0..1])\n @param[in]   c               Central volume (range [0..1])\n @param[in]   sl              Surround left volume (range [0..1])\n @param[in]   sr              Surround right volume (range [0..1])"]
    pub fn mixer_ch_set_vol_dolby(
        ch: ::std::os::raw::c_int,
        fl: f32,
        fr: f32,
        c: f32,
        sl: f32,
        sr: f32,
    );
}
extern "C" {
    #[doc = " @brief Start playing the specified waveform on the specified channel.\n\n This function immediately begins playing the waveform, interrupting any\n other waveform that might have been reproduced on this channel.\n\n Waveform settings are applied to the mixer channel; for instance, the\n frequency of the channel is modified to adapt to the frequency requested\n for correct playback of the waveform.\n\n If the waveform is marked as stereo (channels == 2), the mixer will need\n two channels to play it back. \"ch\" will be used for the left samples,\n while \"ch+1\" will be used for the right samples. After this, it is\n forbidden to call mixer functions on \"ch+1\" until the stereo\n waveform is stopped.\n\n If the same waveform (same pointer) was already being played or was the\n last one that was played on this channel, the channel sample buffer\n is retained, so that any cached samples might be reused.\n\n @param[in]   ch              Channel index\n @param[in]   wave            Waveform to playback"]
    pub fn mixer_ch_play(ch: ::std::os::raw::c_int, wave: *mut waveform_t);
}
extern "C" {
    #[doc = " @brief Change the frequency for the specified channel.\n\n By default, the frequency is the one required by the waveform associated\n to the channel, but this function allows to override.\n\n This function must be called after mixer_ch_play, as otherwise the\n frequency is reset to the default of the waveform.\n\n @param[in]   ch              Channel index\n @param[in]   frequency       Playback frequency (in Hz / samples per second)"]
    pub fn mixer_ch_set_freq(ch: ::std::os::raw::c_int, frequency: f32);
}
extern "C" {
    #[doc = " @brief Change the current playback position within a waveform.\n\n This function can be useful to seek to a specific point of the waveform.\n The position must be specified in number of samples (not bytes). Fractional\n values account for accurate resampling position.\n\n This function must be called after mixer_ch_play, as otherwise the\n position is reset to the beginning of the waveform.\n\n @param[in]   ch              Channel index\n @param[in]   pos             Playback position (in number of samples)"]
    pub fn mixer_ch_set_pos(ch: ::std::os::raw::c_int, pos: f32);
}
extern "C" {
    #[doc = " Read the current playback position of the waveform in the channel.\n\n The position is returned as number of samples. Fractional values account\n for accurate resampling position.\n\n @param[in]   ch              Channel index\n @return                      Playback position (in number of samples)"]
    pub fn mixer_ch_get_pos(ch: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[doc = " @brief Stop playing samples on the specified channel."]
    pub fn mixer_ch_stop(ch: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief  Return true if the channel is currently playing samples."]
    pub fn mixer_ch_playing(ch: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " @brief Configure the limits of a channel with respect to sample bit size, and\n        frequency.\n\n This is an advanced function that should be used with caution, only in\n situations in which it is paramount to control the memory usage of the mixer.\n\n By default, each channel in the mixer is capable of doing 16-bit playback\n with a frequency up to the mixer output sample rate (eg: 44100hz). This means\n that the mixer will allocate sample buffers required for this kind of\n capability.\n\n If it is known that certain channels will use only 8-bit waveforms and/or\n a lower frequency, it is possible to call this function to inform the mixer\n of these limits. This will cause the mixer to reallocate the samplebuffers\n lowering its memory usage (note: multiple calls to this function for different\n channels will of course be batched to cause only one reallocation).\n\n Note also that this function can be used to increase the maximum frequency\n over the mixer sample rate, in case this is required. This works correctly\n but since it causes downsampling, it is generally a waste of memory bandwidth\n and processing power.\n\n \"max_buf_sz\" can be used to limit the maximum buffer size that will be\n allocated for this channel (in bytes). This is a hard cap, applied on top\n of the optimal buffer size that will be calculated by \"max_bits\" and\n \"max_frequency\", and can be used in situations where there are very strong\n memory constraints that must be respected. Use 0 if you don't want to impose\n a limit.\n\n @param[in]   ch              Channel index\n @param[in]   max_bits        Maximum number of bits per sample (or 0 to reset\n                              this to default, which is currently 16).\n @param[in]   max_frequency   Maximum playback frequency for this channel\n                              in Hz / samples per seconds (or 0 to reset\n                              this to default, which is the output sample\n                              rate as specified in #audio_init).\n @param[in]   max_buf_sz      Maximum buffer size in bytes (or o to reset\n                              this default, which is calculated using the\n                              other limites, the playback output rate, and\n                              the number of audio buffers specified in\n                              #audio_init."]
    pub fn mixer_ch_set_limits(
        ch: ::std::os::raw::c_int,
        max_bits: ::std::os::raw::c_int,
        max_frequency: f32,
        max_buf_sz: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Run the mixer to produce output samples.\n\n This function will fetch the required samples from all the channels and\n mix them together according to each channel's settings. The output will\n be written into the specified buffer (out). nsamples is the number of\n samples that should be produced.\n\n A common pattern would be to call #audio_write_begin to obtain an audio\n buffer's pointer, and pass it to mixer_poll.\n\n mixer_poll performs mixing using RSP. If RSP is busy, mixer_poll will\n spin-wait until the RSP is free, to perform audio processing.\n\n Since the N64 AI can only be fed with an even number of samples, mixer_poll\n does not accept odd numbers.\n\n @param[in]   out             Output buffer were samples will be written.\n @param[in]   nsamples        Number of stereo samples to generate."]
    pub fn mixer_poll(out: *mut i16, nsamples: ::std::os::raw::c_int);
}
#[doc = " @brief Callback invoked by mixer_poll at a specified time\n\n A MixerEvent is a callback that is invoked during mixer_poll at a specified\n moment in time (that is, after a specified number of samples have been\n processed). It is useful to implement sequencers that need to update their\n status after a certain number of samples, or effects like volume envelopes\n that must update the channel volumes at regular intervals.\n\n \"ctx\" is an opaque pointer that provides a context to the callback.\n\n If the callback has finished its task, it can return 0 to deregister itself\n from the mixer. Otherwise, it can return a positive number of samples to\n wait before calling it again.\n\n @param[in]   ctx             Opaque pointer to provide context (specified\n                              in #mixer_add_event)\n @return                      0 if the event can be deregistered, otherwise\n                              a positive number of samples to wait before\n                              calling again."]
pub type MixerEvent = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Register a time-based event into the mixer.\n\n Register a new event into the mixer. \"delay\" is the number of samples to\n wait before calling the event callback. \"cb\" is the event callback. \"ctx\"\n is an opaque pointer that will be passed to the callback when invoked.\n\n @param[in]   delay           Number of samples to wait before invoking\n                              the event.\n @param[in]   cb              Event callback to invoke\n @param[in]   ctx             Context opaque pointer to pass to the callback"]
    pub fn mixer_add_event(delay: i64, cb: MixerEvent, ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Deregister a time-based event from the mixer.\n\n Deregister an event from the mixer. \"cb\" is the event callback, and \"ctx\"\n is the opaque context pointer. Notice that an event can also deregister\n itself by returning 0 when called.\n\n @param[in]    cb             Callback that was registered via #mixer_add_event\n @param[in]    ctx            Opaque pointer that was registered with the callback."]
    pub fn mixer_remove_event(cb: MixerEvent, ctx: *mut ::std::os::raw::c_void);
}
#[doc = " @brief Waveform callback function invoked by the mixer to read/generate samples.\n\n WaveformRead is a callback function that will be invoked by the mixer\n whenever a new unavailable portion of the waveform is requested.\n\n *wpos* indicates the absolute position in the waveform from which\n the function must start reading, and *wlen* indicates the minimum number of\n samples to read.\n\n The read function should push into the provided sample buffer\n at least *wlen* samples, using #samplebuffer_append. Producing more samples\n than requested is perfectly fine, they will be stored in the sample buffer\n and remain available for later use. For instance, a compressed waveform\n (eg: VADPCM) might decompress samples in blocks of fixed size, and thus\n push full blocks into the sample buffer, to avoid decoding a block twice.\n\n On the contrary, producing less samples should only be done\n if the read function has absolutely no way to produce more. This should\n happen only when the stream is finished, and only when the waveform length\n was unknown to the mixer (otherwise, the mixer won't ask more samples than\n available in the first place).\n\n The argument *seeking* is a flag that indicates whether the read being\n requested requires seeking or not. If *seeking* is false (most of the times),\n it means that the current read is requesting samples which come immediately\n after the ones that were last read; in other words, the implementation might\n decide to ignore the *wpos* argument and simply continue decoding the audio\n from the place were it last stopped. If *seeking* is true, instead, it means\n that there was a jump in position that should be taken into account.\n\n Normally, a seeking is required in the following situations:\n\n   * At start (#mixer_ch_play): the first read issued by the mixer will\n     be at position 0 with `seeking == true` (unless the waveform was\n     already partially cached in the sample buffer's channel).\n   * At user request (#mixer_ch_set_pos).\n   * At loop: if a loop is specified in the waveform (`loop_len != 0`), the\n     mixer will seek when required to execute the loop.\n\n Notice that producing more samples than requested in *wlen* might break\n the 8-byte buffer alignment guarantee that #samplebuffer_append tries to\n provide. For instance, if the read function is called requesting 24 samples,\n but it produces 25 samples instead, the alignment in the buffer will be lost,\n and next call to #samplebuffer_append will return an unaligned pointer.\n\n @param[in]  ctx     Opaque pointer that is provided as context to the function,\n                     and is specified in the waveform.\n @param[in]  sbuf    Samplebuffer into which read samples should be stored.\n @param[in]  wpos    Absolute position in the waveform to read from (in samples).\n @param[in]  wlen    Minimum number of samples to read (in samples).\n @param[in]  seeking True if this call requires seeking in the waveform, false\n                     if this read is consecutive to the last one."]
pub type WaveformRead = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        sbuf: *mut samplebuffer_t,
        wpos: ::std::os::raw::c_int,
        wlen: ::std::os::raw::c_int,
        seeking: bool,
    ),
>;
#[doc = " @brief A waveform that can be played back through the mixer.\n\n waveform_t represents a waveform that can be played back by the mixer.\n A waveform_t does not hold the actual samples because most real-world use\n cases do not keep all samples in memory, but rather load them and/or\n decompress them in real-time while the playback is happening.\n So waveform_t instead should be thought of as the generator of a\n waveform.\n\n To create a waveform, use one of waveform implementations such as wav64.\n Waveform implementations are in charge of generating the samples by actually\n implementing an audio format like VADPCM or MPEG-2.\n\n Waveforms can produce samples as 8-bit or 16-bit. Samples must always be\n signed. Stereo waveforms (interleaved samples) are supported: when used\n with #mixer_ch_play, they will use automatically two channels (the specified\n one and the following)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct waveform_s {
    #[doc = " @brief Name of the waveform (for debugging purposes)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " @brief Width of a sample of this waveform, in bits.\n\n Supported values are 8 or 16. Notice that samples must always be signed."]
    pub bits: u8,
    #[doc = " @brief Number of interleaved audio channels in this waveforms.\n\n Supported values are 1 and 2 (mono and stereo waveforms). Notice that\n a stereo waveform will use two consecutive mixer channels to be played back."]
    pub channels: u8,
    #[doc = " @brief Desired playback frequency (in samples per second, aka Hz)."]
    pub frequency: f32,
    #[doc = " @brief Length of the waveform, in number of samples.\n\n If the length is not known, this value should be set to #WAVEFORM_UNKNOWN_LEN."]
    pub len: ::std::os::raw::c_int,
    #[doc = " @brief Length of the loop of the waveform (from the end).\n\n This value describes how many samples of the tail of the waveform needs\n to be played in a loop. For instance, if len==1200 and loop_len=500, the\n waveform will be played once, and then the last 700 samples will be\n repeated in loop."]
    pub loop_len: ::std::os::raw::c_int,
    #[doc = " @brief Read function of the waveform.\n\n This is the callback that will be invoked by the mixer to generate the\n samples. See #WaveformRead for more information."]
    pub read: WaveformRead,
    #[doc = " @brief Opaque pointer provided as context to the read function."]
    pub ctx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_waveform_s() {
    const UNINIT: ::std::mem::MaybeUninit<waveform_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<waveform_s>(),
        40usize,
        concat!("Size of: ", stringify!(waveform_s))
    );
    assert_eq!(
        ::std::mem::align_of::<waveform_s>(),
        8usize,
        concat!("Alignment of ", stringify!(waveform_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(waveform_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(waveform_s),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(waveform_s),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(waveform_s),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(waveform_s),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loop_len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(waveform_s),
            "::",
            stringify!(loop_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(waveform_s),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(waveform_s),
            "::",
            stringify!(ctx)
        )
    );
}
#[doc = " Tagged pointer to an array of samples. It contains both the void*\n sample pointer, and byte-per-sample information (encoded as shift value)."]
pub type sample_ptr_t = u32;
#[doc = " samplebuffer_t is a circular buffer of samples. It is used by the mixer\n to store and cache the samples required for playback on each channel.\n The mixer creates a sample buffer for each initialized channel. The size\n of the buffers is calculated for optimal playback, and might grow depending\n on channel usage (what waveforms are played on each channel).\n\n The mixer follows a \"pull\" architecture. During mixer_poll, it will call\n samplebuffer_get() to extract samples from the buffer. If the required\n samples are not available, the sample buffer will callback the waveform\n decoder to produce more samples, through the WaveformRead API. The\n waveform read function will push samples into the buffer via samplebuffer_append,\n so that they become available for the mixer. The decoder can be configured\n with samplebuffer_set_decoder.\n\n The current implementation of samplebuffer does not achieve full zero copy,\n because when the buffer is full, it is flushed and samples that need to\n be preserved (that is, already in the buffer but not yet played back) are\n copied back at the beginning of the buffer with the CPU. This limitation\n exists because the RSP ucode (rsp_audio.S) isn't currently able to \"wrap around\"\n in the sample buffer. In future, this limitation could be lifted to achieve\n full zero copy.\n\n The sample buffer tries to always stay 8-byte aligned to simplify operations\n of decoders that might need to use DMA transfers (either PI DMA or RSP DMA).\n To guarantee this property, #WaveformRead must collaborate by decoding\n the requested number of samples. If WaveformRead decodes a different\n number of samples, the alignment might be lost. Moreover, it always guarantees\n that the buffer has the same 2-byte phase of the waveforms (that is, odd\n samples of the waveforms are stored at odd addresses in memory); this is\n the minimal property required by #dma_read (libdragon's optimized PI DMA\n transfer for unaligned addresses).\n\n In general, the sample buffer assumes that the contained data is committed\n to physical memory, not just CPU cache. It is responsibility of the client\n to flush DMA cache (via data_cache_writeback) if samples are written\n via CPU."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct samplebuffer_s {
    #[doc = " Tagged pointer to the actual buffer. Lower bits contain bit-per-shift."]
    pub ptr_and_flags: sample_ptr_t,
    #[doc = " Size of the buffer (in samples)."]
    pub size: ::std::os::raw::c_int,
    #[doc = " Absolute position in the waveform of the first sample\n in the sample buffer (the sample at index 0). It keeps track of\n which part of the waveform this sample buffer contains."]
    pub wpos: ::std::os::raw::c_int,
    #[doc = " Write pointer in the sample buffer (expressed as index of samples).\n Since sample buffers are always filled from index 0, it is also\n the number of samples stored in the buffer."]
    pub widx: ::std::os::raw::c_int,
    #[doc = " Read pointer in the sample buffer (expressed as index of samples).\n It remembers which sample was last read. Assuming a forward\n streaming, it is used by the sample buffer to discard unused samples\n when not needed anymore."]
    pub ridx: ::std::os::raw::c_int,
    #[doc = " wv_read is invoked by samplebuffer_get whenever more samples are\n requested by the mixer. See #WaveformRead for more information."]
    pub wv_read: WaveformRead,
    #[doc = " wv_ctx is the opaque pointer to pass as context to decoder functions."]
    pub wv_ctx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_samplebuffer_s() {
    const UNINIT: ::std::mem::MaybeUninit<samplebuffer_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<samplebuffer_s>(),
        40usize,
        concat!("Size of: ", stringify!(samplebuffer_s))
    );
    assert_eq!(
        ::std::mem::align_of::<samplebuffer_s>(),
        8usize,
        concat!("Alignment of ", stringify!(samplebuffer_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr_and_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(samplebuffer_s),
            "::",
            stringify!(ptr_and_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(samplebuffer_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wpos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(samplebuffer_s),
            "::",
            stringify!(wpos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).widx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(samplebuffer_s),
            "::",
            stringify!(widx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ridx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(samplebuffer_s),
            "::",
            stringify!(ridx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wv_read) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(samplebuffer_s),
            "::",
            stringify!(wv_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wv_ctx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(samplebuffer_s),
            "::",
            stringify!(wv_ctx)
        )
    );
}
extern "C" {
    #[doc = " Initialize the sample buffer by binding it to the specified memory buffer.\n\n The sample buffer is guaranteed to be 8-bytes aligned, so the specified\n memory buffer must follow this constraint. Moreover, the buffer must be\n in the uncached segment and not loaded in any CPU cacheline. It is\n strongly advised to allocate the buffer via #malloc_uncached, that takes\n care of these constraints.\n\n @param[in]   buf              Sample buffer\n @param[in]   uncached_mem     Memory buffer to use. Must be 8-byte aligned,\n                               and in the uncached segment.\n @param[in]   size             Size of the memory buffer, in bytes."]
    pub fn samplebuffer_init(
        buf: *mut samplebuffer_t,
        uncached_mem: *mut u8,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Configure the bit width of the samples stored in the buffer.\n\n Valid values for \"bps\" are 1, 2, or 4: 1 can be used for 8-bit mono samples,\n 2 for either 8-bit interleaved stereo or 16-bit mono, and 4 for 16-bit\n interleaved stereo.\n\n @param[in]   buf     Sample buffer\n @param[in]   bps     Bytes per sample."]
    pub fn samplebuffer_set_bps(buf: *mut samplebuffer_t, bps: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Connect a waveform reader callback to this sample buffer. The waveform\n will be use to produce samples whenever they are required by the mixer\n as playback progresses.\n\n \"read\" is the main decoding function, that is invoked to produce a specified\n number of samples. Normally, the function is invoked by #samplebuffer_get,\n whenever the mixer requests more samples. See #WaveformRead for more\n information.\n\n @param[in]       buf     Sample buffer\n @param[in]       read    Waveform reading function, that produces samples.\n @param[in]       ctx     Opaque context that will be passed to the read\n                          function."]
    pub fn samplebuffer_set_waveform(
        buf: *mut samplebuffer_t,
        read: WaveformRead,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Get a pointer to specific set of samples in the buffer (zero-copy).\n\n \"wpos\" is the absolute waveform position of the first sample that the\n caller needs access to. \"wlen\" is the number of requested samples.\n\n The function returns a pointer within the sample buffer where the samples\n should be read, and optionally changes \"wlen\" with the maximum number of\n samples that can be read. \"wlen\" is always less or equal to the requested value.\n\n If the samples are available in the buffer, they will be returned immediately.\n Otherwise, if the samplebuffer has a sample decoder registered via\n samplebuffer_set_decoder, the decoder \"read\" function is called once to\n produce the samples.\n\n If \"wlen\" is changed with a value less than \"wlen\", it means that\n not all samples were available in the buffer and it was not possible to\n generate more, so the caller should not loop calling this function, but\n rather use what was obtained and possibly pad with silence.\n\n @param[in]       buf     Sample buffer\n @param[in]       wpos    Absolute waveform position of the first samples to\n                          return.\n @param[in,out]   wlen    Number of samples to return. After return, it is\n                          modified with the actual number of samples that\n                          have been returned.\n @return                  Pointer to samples."]
    pub fn samplebuffer_get(
        buf: *mut samplebuffer_t,
        wpos: ::std::os::raw::c_int,
        wlen: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Append samples into the buffer (zero-copy).\n\n \"wlen\" is the number of samples that the caller will append.\n\n The function returns a pointer within the sample buffer where the samples\n should be written. The samples to be written to physical memory, not just\n CPU cache, and to enforce this, the function returns a pointer in the\n uncached segment. Most of the times, we expect samples to be generated\n or manipulated via RSP/DMA anyway.\n\n The function is meant only to \"append\" samples, as in add samples that are\n consecutive within the waveform to the ones already stored in the sample\n buffer. This is necessary because #samplebuffer_t can only store a single\n range of samples of the waveform; there is no way to hold two disjoint\n ranges.\n\n For instance, if the sample buffer currently contains 50 samples\n starting from position 100 in the waverform, the next call to\n samplebuffer_append will append samples starting at 150.\n\n If required, samplebuffer_append will discard older samples to make space\n for the new ones, through #samplebuffer_discard. It will only discard samples\n that come before the \"wpos\" specified in the last #samplebuffer_get call, so\n to make sure that nothing required for playback is discarded. If there is\n not enough space in the buffer, it will assert.\n\n @param[in]   buf     Sample buffer\n @param[in]   wlen    Number of samples to append.\n @return              Pointer to the area where new samples can be written."]
    pub fn samplebuffer_append(
        buf: *mut samplebuffer_t,
        wlen: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Discard all samples from the buffer that come before a specified\n absolute waveform position.\n\n This function can be used to discard samples that are not needed anymore\n in the sample buffer. \"wpos\" specifies the absolute position of the first\n sample that should be kept: all samples that come before will be discarded.\n This function will silently do nothing if there are no samples to discard.\n\n @param[in]   buf     Sample buffer\n @param[in]   wpos    Absolute waveform position of the first sample that\n                      must be kept."]
    pub fn samplebuffer_discard(buf: *mut samplebuffer_t, wpos: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Flush (reset) the sample buffer to empty status, discarding all samples.\n\n @param[in]   buf     Sample buffer."]
    pub fn samplebuffer_flush(buf: *mut samplebuffer_t);
}
extern "C" {
    #[doc = " Close the sample buffer.\n\n After calling close, the sample buffer must be initialized again before\n using it.\n\n @param[in]   buf     Sample buffer."]
    pub fn samplebuffer_close(buf: *mut samplebuffer_t);
}
#[doc = " @brief WAV64 structure\n\n This structure is initialized by #wav64_open to refer to an opened WAV64\n file. It is meant to be played back through the audio mixer, implementing\n the #waveform_t interface. As such, samples are not preloaded in memory\n but rather loaded on request when needed for playback, streaming directly\n from ROM. See #waveform_t for more details.\n\n Use #wav64_play to playback. For more advanced usage, call directly the\n mixer functions, accessing the #wave structure field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wav64_t {
    #[doc = " @brief #waveform_t for this WAV64.\n\n Access and use this field directly with the mixer, if needed."]
    pub wave: waveform_t,
    #[doc = " @brief Absolute ROM address of WAV64"]
    pub rom_addr: u32,
}
#[test]
fn bindgen_test_layout_wav64_t() {
    const UNINIT: ::std::mem::MaybeUninit<wav64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wav64_t>(),
        48usize,
        concat!("Size of: ", stringify!(wav64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<wav64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(wav64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wave) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wav64_t),
            "::",
            stringify!(wave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rom_addr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wav64_t),
            "::",
            stringify!(rom_addr)
        )
    );
}
extern "C" {
    #[doc = " @brief Open a WAV64 file for playback.\n\n This function opens the file, parses the header, and initializes for\n playing back through the audio mixer.\n\n @param   wav         Pointer to wav64_t structure\n @param   fn          Filename of the wav64 (with filesystem prefix). Currently,\n                      only files on DFS (\"rom:/\") are supported."]
    pub fn wav64_open(wav: *mut wav64_t, fn_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Configure a WAV64 file for looping playback."]
    pub fn wav64_set_loop(wav: *mut wav64_t, loop_: bool);
}
extern "C" {
    #[doc = " @brief Start playing a WAV64 file.\n\n This is just a simple wrapper that calls #mixer_ch_play on the WAV64's\n waveform (#wav64_t::wave). For advanced usages, please call directly the\n mixer functions.\n\n @param   wav         Pointer to wav64_t structure\n @param   ch          Channel of the mixer to use for playback."]
    pub fn wav64_play(wav: *mut wav64_t, ch: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xm_context_s {
    _unused: [u8; 0],
}
#[doc = " @cond"]
pub type xm_context_t = xm_context_s;
#[doc = " @brief Player of a .XM64 file.\n\n This structure holds the state a player of a XM64 module. It can be\n initialized using #xm64player_open, and played with #xm64player_play.\n\n See the rest of this module for more functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xm64player_s {
    #[doc = "< libxm context"]
    pub ctx: *mut xm_context_t,
    #[doc = "< array of all waveforms (one per XM \"sample\")"]
    pub waves: *mut waveform_t,
    #[doc = "< number of wavers (XM \"samples\")"]
    pub nwaves: ::std::os::raw::c_int,
    #[doc = "< open handle of XM64 file"]
    pub fh: *mut FILE,
    #[doc = "< first channel used in the mixer"]
    pub first_ch: ::std::os::raw::c_int,
    #[doc = "< playing flag"]
    pub playing: bool,
    #[doc = "< true if the XM is configured to loop"]
    pub looping: bool,
    #[doc = "< seeking to be performed"]
    pub seek: xm64player_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xm64player_s__bindgen_ty_1 {
    pub patidx: ::std::os::raw::c_int,
    pub row: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xm64player_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<xm64player_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xm64player_s__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(xm64player_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<xm64player_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(xm64player_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patidx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s__bindgen_ty_1),
            "::",
            stringify!(patidx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s__bindgen_ty_1),
            "::",
            stringify!(row)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s__bindgen_ty_1),
            "::",
            stringify!(tick)
        )
    );
}
#[test]
fn bindgen_test_layout_xm64player_s() {
    const UNINIT: ::std::mem::MaybeUninit<xm64player_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xm64player_s>(),
        56usize,
        concat!("Size of: ", stringify!(xm64player_s))
    );
    assert_eq!(
        ::std::mem::align_of::<xm64player_s>(),
        8usize,
        concat!("Alignment of ", stringify!(xm64player_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).waves) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s),
            "::",
            stringify!(waves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nwaves) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s),
            "::",
            stringify!(nwaves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s),
            "::",
            stringify!(fh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_ch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s),
            "::",
            stringify!(first_ch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).playing) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s),
            "::",
            stringify!(playing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).looping) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s),
            "::",
            stringify!(looping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xm64player_s),
            "::",
            stringify!(seek)
        )
    );
}
#[doc = " @brief Player of a .XM64 file.\n\n This structure holds the state a player of a XM64 module. It can be\n initialized using #xm64player_open, and played with #xm64player_play.\n\n See the rest of this module for more functions."]
pub type xm64player_t = xm64player_s;
extern "C" {
    #[doc = " @brief Open a XM64 module file and prepare for playback.\n\n This function requires the mixer to have been already initialized\n (via mixer_init).\n\n @param player Pointer to the xm64player_t player structure to use\n @param fn     Filename of the XM64 (with filesystem prefix). Currently,\n               only files on DFS (\"rom:/\") are supported."]
    pub fn xm64player_open(player: *mut xm64player_t, fn_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Get the number of channels in the XM64 file\n\n Notice that the player needs to use one mixer channel per each XM64 channel."]
    pub fn xm64player_num_channels(player: *mut xm64player_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Configure a XM64 file for looping.\n\n By default, XM64 files will be played in loop. Use this function\n to disable looping.\n\n @param[in] player\n            XM64 player\n @param[in] loop\n            true to enable looping, false to disable looping."]
    pub fn xm64player_set_loop(player: *mut xm64player_t, loop_: bool);
}
extern "C" {
    #[doc = " @brief Start playing the XM64 module.\n\n Notice that the player needs to use one mixer channel per each XM64 channel.\n\n @param player \tXM64 player\n @param first_ch \tIndex of the first mixer channel to use for playback."]
    pub fn xm64player_play(player: *mut xm64player_t, first_ch: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Stop XM playback.\n\n The XM module will keep the current position. Use xmplayer_play to continue\n playback."]
    pub fn xm64player_stop(player: *mut xm64player_t);
}
extern "C" {
    #[doc = " @brief Read the current position of the XM module.\n\n The function returns the current position expressed as\n pattern/row (internal XM position), and also expressed\n as number of seconds. You can pass NULL to information\n that you are not interested in receiving.\n\n @param player        XM64 player\n @param[out] patidx   Index of the XM pattern\n @param[out] row      Row within the pattern\n @param[out] secs     Total number of seconds"]
    pub fn xm64player_tell(
        player: *mut xm64player_t,
        patidx: *mut ::std::os::raw::c_int,
        row: *mut ::std::os::raw::c_int,
        secs: *mut f32,
    );
}
extern "C" {
    #[doc = " @brief Seek to a specific position of the XM module.\n\n Seeking in XM module is \"broken by design\". What this function does\n is to move the playback cursor to the specified position, but\n it doesn't take into effect what samples / effects should be active\n at the seeking point.\n\n @param player \t\tXM64 player\n @param patidx \t\tIndex of the XM pattern to seek to\n @param row \t\t\tRow within the pattern to seek to\n @param tick \t\t\tTick within the row to seek to"]
    pub fn xm64player_seek(
        player: *mut xm64player_t,
        patidx: ::std::os::raw::c_int,
        row: ::std::os::raw::c_int,
        tick: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Change the volume of the player.\n\n This allows to tune the volume of playback. The default volume is 1.0; smaller\n values will lower the volume, higher values will amplificate (but may clip)."]
    pub fn xm64player_set_vol(player: *mut xm64player_t, volume: f32);
}
extern "C" {
    #[doc = " @brief Set a custom effect callback to allow music synchronization.\n\n This function configures a callback that will be called whenever the player\n finds an unknown / unsupported effect in any channel. These unknown effects\n can be used to add custom \"sync cues\" in the music score, and synchronize\n graphic effects or gameplay logic to them.\n\n There are many unused effect letters in XM format. For instance, a good\n choice can be effect Xxx which is used as modplug hack for MIDI support,\n but is unimplemented by standard XM players like this one.\n\n The callback will be called passing as arguments a custom context, the\n channel number, and the effect code and the effect parameter. The effect\n code is the code in extended hex format (A-F are 10-15 as in normal hex,\n but then G-Z are 16-35), while the effect parameter is one free byte that\n can be inserted in the music score."]
    pub fn xm64player_set_effect_callback(
        player: *mut xm64player_t,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: u8, arg3: u8, arg4: u8),
        >,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Close and deallocate the XM64 player."]
    pub fn xm64player_close(player: *mut xm64player_t);
}
#[doc = " @brief A AY-3-8910 channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AYChannel {
    #[doc = "< Period (in ticks) of the current tone"]
    pub tone_period: u16,
    #[doc = "< Volume of the tone (0x10 -> use envelope)"]
    pub tone_vol: u8,
    #[doc = "< Enable flag of the tone (0 is enabled)"]
    pub tone_en: u8,
    #[doc = "< Enable flag of the noise for this channel (0 is enabled)"]
    pub noise_en: u8,
    #[doc = "< Current tick count for the period"]
    pub count: u16,
    #[doc = "< Current output value for this channel"]
    pub out: u8,
}
#[test]
fn bindgen_test_layout_AYChannel() {
    const UNINIT: ::std::mem::MaybeUninit<AYChannel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AYChannel>(),
        10usize,
        concat!("Size of: ", stringify!(AYChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<AYChannel>(),
        2usize,
        concat!("Alignment of ", stringify!(AYChannel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tone_period) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AYChannel),
            "::",
            stringify!(tone_period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tone_vol) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AYChannel),
            "::",
            stringify!(tone_vol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tone_en) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(AYChannel),
            "::",
            stringify!(tone_en)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noise_en) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AYChannel),
            "::",
            stringify!(noise_en)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(AYChannel),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AYChannel),
            "::",
            stringify!(out)
        )
    );
}
#[doc = " @brief Envelope of AY-3-8910"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AYEnvelope {
    #[doc = "< Period (in ticks) of the envelope"]
    pub period: u16,
    #[doc = "< Shape of the envelope (jigsaw, etc.)"]
    pub shape: u8,
    #[doc = "< 0x0 if in attack, 0xF if in the release"]
    pub attack: u8,
    #[doc = "< True if attack and release alternate (jigsaw)"]
    pub alternate: u8,
    #[doc = "< True if the envelope holds after attack"]
    pub hold: u8,
    #[doc = "< Current tick count for the period"]
    pub count: u16,
    #[doc = "< Current step of the envelope"]
    pub step: i16,
    #[doc = "< Current output volume"]
    pub vol: u8,
    #[doc = "< True if the envelope is currently holding"]
    pub holding: u8,
}
#[test]
fn bindgen_test_layout_AYEnvelope() {
    const UNINIT: ::std::mem::MaybeUninit<AYEnvelope> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AYEnvelope>(),
        12usize,
        concat!("Size of: ", stringify!(AYEnvelope))
    );
    assert_eq!(
        ::std::mem::align_of::<AYEnvelope>(),
        2usize,
        concat!("Alignment of ", stringify!(AYEnvelope))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AYEnvelope),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shape) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AYEnvelope),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attack) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(AYEnvelope),
            "::",
            stringify!(attack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alternate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AYEnvelope),
            "::",
            stringify!(alternate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hold) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(AYEnvelope),
            "::",
            stringify!(hold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(AYEnvelope),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AYEnvelope),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vol) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AYEnvelope),
            "::",
            stringify!(vol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).holding) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(AYEnvelope),
            "::",
            stringify!(holding)
        )
    );
}
#[doc = " @brief Noise of AY-3-8910"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AYNoise {
    #[doc = "< Period (in ticks) of the noise"]
    pub period: u8,
    #[doc = "< Current tick count for the period"]
    pub count: u8,
    #[doc = "< Current output value"]
    pub out: u32,
}
#[test]
fn bindgen_test_layout_AYNoise() {
    const UNINIT: ::std::mem::MaybeUninit<AYNoise> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AYNoise>(),
        8usize,
        concat!("Size of: ", stringify!(AYNoise))
    );
    assert_eq!(
        ::std::mem::align_of::<AYNoise>(),
        4usize,
        concat!("Alignment of ", stringify!(AYNoise))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AYNoise),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AYNoise),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AYNoise),
            "::",
            stringify!(out)
        )
    );
}
#[doc = " @brief A AY-3-8910 emulator\n\n AY-3-8910 is a 4-bit PSG, popular in the 80s, that was used in many\n game consoles and PCs. It features 3 channels producing square waveforms\n at programmable periods and volumes, plus a noise generator that can be\n activated on each channel, and a volume envelope.\n\n This emulator has been heavily optimized to be able to perform fast enough\n on the N64 hardware to be used as background music. Specifically, it is\n used by #ym64player_t to play back YM modules."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AY8910 {
    #[doc = "< Callback for I/O port reads"]
    pub PortRead: ::std::option::Option<unsafe extern "C" fn(idx: ::std::os::raw::c_int) -> u8>,
    #[doc = "< Callback for I/O port writes"]
    pub PortWrite: ::std::option::Option<unsafe extern "C" fn(idx: ::std::os::raw::c_int, val: u8)>,
    #[doc = "< Current value on the address line"]
    pub addr: u8,
    #[doc = "< State of the internal registers"]
    pub regs: [u8; 16usize],
    #[doc = "< Configuration and state of the channels"]
    pub ch: [AYChannel; 3usize],
    #[doc = "< Configuration and state of the noise"]
    pub ns: AYNoise,
    #[doc = "< Configuration and state of the envelope"]
    pub env: AYEnvelope,
}
#[test]
fn bindgen_test_layout_AY8910() {
    const UNINIT: ::std::mem::MaybeUninit<AY8910> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AY8910>(),
        88usize,
        concat!("Size of: ", stringify!(AY8910))
    );
    assert_eq!(
        ::std::mem::align_of::<AY8910>(),
        8usize,
        concat!("Alignment of ", stringify!(AY8910))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PortRead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AY8910),
            "::",
            stringify!(PortRead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PortWrite) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AY8910),
            "::",
            stringify!(PortWrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AY8910),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(AY8910),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ch) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(AY8910),
            "::",
            stringify!(ch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AY8910),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).env) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AY8910),
            "::",
            stringify!(env)
        )
    );
}
extern "C" {
    #[doc = " @brief Reset the AY8910 emulator."]
    pub fn ay8910_reset(ay: *mut AY8910);
}
extern "C" {
    #[doc = " @brief Configure the I/O port callbacks."]
    pub fn ay8910_set_ports(
        ay: *mut AY8910,
        PortRead: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> u8>,
        PortWrite: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: u8),
        >,
    );
}
extern "C" {
    #[doc = " @brief Write to the AY8910 address line."]
    pub fn ay8910_write_addr(ay: *mut AY8910, addr: u8);
}
extern "C" {
    #[doc = " @brief Write to the AY8910 data line."]
    pub fn ay8910_write_data(ay: *mut AY8910, val: u8);
}
extern "C" {
    #[doc = " @brief Read from the AY8910 data line."]
    pub fn ay8910_read_data(ay: *mut AY8910) -> u8;
}
extern "C" {
    #[doc = " @brief Return true if ay8910 is currently muted (all channels disabled)"]
    pub fn ay8910_is_mute(ay: *mut AY8910) -> bool;
}
extern "C" {
    #[doc = " @brief Generate audio for the specified number of samples.\n\n \"nsamples\" is the number of samples after decimation (so the exact number of\n samples written in the output buffer)."]
    pub fn ay8910_gen(
        ay: *mut AY8910,
        out: *mut i16,
        nsamples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LHANewDecoder {
    _unused: [u8; 0],
}
#[doc = " @cond"]
pub type LHANewDecoder = _LHANewDecoder;
#[doc = " @brief Player of a .YM64 file.\n\n This structure holds the state a player of a YM64 module. It can be\n initialized using #ym64player_open, and played with #ym64player_play.\n\n See the rest of this module for more functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ym64player_t {
    #[doc = "< waveform for playback with the mixer"]
    pub wave: waveform_t,
    #[doc = "< Open file handle"]
    pub f: *mut FILE,
    #[doc = "< Optional LHA decoder (compressed YM files)"]
    pub decoder: *mut LHANewDecoder,
    #[doc = "< Starting offset of the first audio frame"]
    pub start_off: ::std::os::raw::c_int,
    #[doc = "< AY8910 emulator"]
    pub ay: AY8910,
    #[doc = "< Current cached value of the AY registers"]
    pub regs: [u8; 16usize],
    #[doc = "< Number of YM audio frames"]
    pub nframes: u32,
    #[doc = "< Operating frequency of the AY chip"]
    pub chipfreq: u32,
    #[doc = "< Frequency of an audio frame (typically 50Hz or 60Hz)"]
    pub playfreq: u16,
    #[doc = "< Current audio frame being played"]
    pub curframe: ::std::os::raw::c_int,
    #[doc = "< First channel used in the mixer for playback"]
    pub first_ch: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ym64player_t() {
    const UNINIT: ::std::mem::MaybeUninit<ym64player_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ym64player_t>(),
        192usize,
        concat!("Size of: ", stringify!(ym64player_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ym64player_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ym64player_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wave) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(wave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(decoder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_off) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(start_off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ay) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(ay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nframes) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(nframes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chipfreq) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(chipfreq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).playfreq) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(playfreq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curframe) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(curframe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_ch) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_t),
            "::",
            stringify!(first_ch)
        )
    );
}
#[doc = " @brief Structure containing information about a YM song"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ym64player_songinfo_t {
    #[doc = "< Name of the song"]
    pub name: [::std::os::raw::c_char; 128usize],
    #[doc = "< Author of the song"]
    pub author: [::std::os::raw::c_char; 128usize],
    #[doc = "< Comment of the song"]
    pub comment: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_ym64player_songinfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<ym64player_songinfo_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ym64player_songinfo_t>(),
        384usize,
        concat!("Size of: ", stringify!(ym64player_songinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ym64player_songinfo_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ym64player_songinfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_songinfo_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).author) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_songinfo_t),
            "::",
            stringify!(author)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comment) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ym64player_songinfo_t),
            "::",
            stringify!(comment)
        )
    );
}
extern "C" {
    #[doc = " @brief Open a YM64 file for playback\n\n @param[in]  \tplayer \t\tYM64 player to initialize\n @param[in] \tfn \t\t\tFilename of the XM64 (with filesystem prefix, e.g. `rom://`).\n @param[out] \tinfo \t\tOptional structure to fill with information on the song\n                          (pass NULL if not needed)"]
    pub fn ym64player_open(
        player: *mut ym64player_t,
        fn_: *const ::std::os::raw::c_char,
        info: *mut ym64player_songinfo_t,
    );
}
extern "C" {
    #[doc = " @brief Return the number of channels used in the mixer for playback.\n\n Depending on the AY emulator compile-time settings, this could be either\n 1 or 2 (mono or stereo). Notice that the YM64 currently mixes itself the\n 3 internal channels of the AY8910 chip, so only a final output stream\n is passed to the mixer.\n\n @param[in]  \tplayer \t\tYM64 player\n @return  \t\t\t\tNumber of mixer channels."]
    pub fn ym64player_num_channels(player: *mut ym64player_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Start playback of a YM file.\n\n @param[in]\tplayer \t\tYM64 player\n @param[in] \tfirst_ch\tFirst mixer channel to use for playback"]
    pub fn ym64player_play(player: *mut ym64player_t, first_ch: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Read the total duration the YM module.\n\n The function returns the total duration of the YM module, in ticks (internal\n YM position) or seconds. You can pass NULL to information that you are not\n interested in receiving.\n\n @param[in]\tplayer \t\tYM64 player\n @param[out] \tlen \t\tTotal duration in ticks\n @param[out] \tsecs \t\tTotal duration in seconds"]
    pub fn ym64player_duration(
        player: *mut ym64player_t,
        len: *mut ::std::os::raw::c_int,
        secs: *mut f32,
    );
}
extern "C" {
    #[doc = " @brief Read the current position of the YM module.\n\n The function returns the current position expressed in ticks (internal\n YM position), and also expressed as number of seconds. You can pass NULL\n to information that you are not interested in receiving.\n\n @param[in]\tplayer \t\tYM64 player\n @param[out] \tpos \t\tCurrent position in ticks\n @param[out] \tsecs \t\tCurrent position in seconds"]
    pub fn ym64player_tell(
        player: *mut ym64player_t,
        pos: *mut ::std::os::raw::c_int,
        secs: *mut f32,
    );
}
extern "C" {
    #[doc = " @brief Seek to a specific position in the YM module.\n\n The function seeks to a new absolute position expressed in ticks (internal\n YM position). Notice that it's not possible to seek in a YM64 file that has\n been compressed. audioconv64 compresses YM files by default.\n\n @param[in]\tplayer \t\tYM64 player\n @param[out] \tpos \t\tAbsolute position in ticks\n @return                  True if it was possible to seek, false if\n                          the file is compressed."]
    pub fn ym64player_seek(player: *mut ym64player_t, pos: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " @brief Stop YM playback.\n\n The YM module will keep the current position. Use #ym64player_play to continue\n playback."]
    pub fn ym64player_stop(player: *mut ym64player_t);
}
extern "C" {
    #[doc = " @brief Close and deallocate the YM64 player."]
    pub fn ym64player_close(player: *mut ym64player_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rspq_block_s {
    _unused: [u8; 0],
}
#[doc = " @brief A preconstructed block of commands\n\n To improve performance of execution of sequences of commands, it is possible\n to create a \"block\". A block is a fixed set of commands that is created\n once and executed multiple times.\n\n To create a block, use #rspq_block_begin and #rspq_block_end. After creation,\n you can use #rspq_block_run at any point to run it. If you do not need the\n block anymore, use #rspq_block_free to dispose it."]
pub type rspq_block_t = rspq_block_s;
#[doc = " @brief A syncpoint in the queue\n\n A syncpoint can be thought of as a pointer to a position in the command queue.\n After creation, it is possible to later check whether the RSP has reached\n that position or not.\n\n To create a syncpoint, use #rspq_syncpoint_new that returns a syncpoint that\n references the current position. Call #rspq_syncpoint_check or #rspq_syncpoint_wait\n to respectively do a single check or block waiting for the syncpoint to be\n reached by RSP.\n\n Syncpoints are implemented using interrupts, so they have a light but non\n trivial overhead. Do not abuse them. For instance, it is reasonable to use\n tens of syncpoints per frame, but not hundreds or thousands of them.\n\n @note A valid syncpoint is an integer greater than 0."]
pub type rspq_syncpoint_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " @brief Initialize the RSPQ library.\n\n This should be called by the initialization functions of the higher-level\n libraries using the RSP command queue. It can be safely called multiple\n times without side effects.\n\n It is not required by applications to call this explicitly in the main\n function."]
    pub fn rspq_init();
}
extern "C" {
    #[doc = " @brief Shut down the RSPQ library.\n\n This is mainly used for testing."]
    pub fn rspq_close();
}
extern "C" {
    #[doc = " @brief Register a rspq overlay into the RSP queue engine.\n\n This function registers a rspq overlay into the queue engine.\n An overlay is a RSP ucode that has been written to be compatible with the\n queue engine (see rsp_queue.inc for instructions) and is thus able to\n execute commands that are enqueued in the queue. An overlay doesn't have\n a single entry point: it exposes multiple functions bound to different\n commands, that will be called by the queue engine when the commands are enqueued.\n\n The function returns the overlay ID, which is the ID to use to enqueue\n commands for this overlay. The overlay ID must be passed to #rspq_write\n when adding new commands. rspq allows up to 16 overlays to be registered\n simultaneously, as the overlay ID occupies the top 4 bits of each command.\n The lower 4 bits specify the command ID, so in theory each overlay could\n offer a maximum of 16 commands. To overcome this limitation, this function\n will reserve multiple consecutive IDs in case an overlay with more than 16\n commands is registered. These additional IDs are silently occupied and\n never need to be specified explicitly when queueing commands.\n\n For example if an overlay with 32 commands were registered, this function\n could return ID 0x60, and ID 0x70 would implicitly be reserved as well.\n To queue the twenty first command of this overlay, you would write\n `rspq_write(ovl_id, 0x14, ...)`, where `ovl_id` is the value that was returned\n by this function.\n\n @param      overlay_ucode  The overlay to register\n\n @return     The overlay ID that has been assigned to the overlay. Note that\n             this value will be preshifted by 28 (eg: 0x60000000 for ID 6),\n             as this is the expected format used by #rspq_write."]
    pub fn rspq_overlay_register(overlay_ucode: *mut rsp_ucode_t) -> u32;
}
extern "C" {
    #[doc = " @brief Register an overlay into the RSP queue engine assigning a static ID to it\n\n This function works similar to #rspq_overlay_register, except it will\n attempt to assign the specified ID to the overlay instead of automatically\n choosing one. Note that if the ID (or a consecutive IDs) is already used\n by another overlay, this function will assert, so careful usage is advised.\n\n Assigning a static ID can mostly be useful for debugging purposes.\n\n @param      overlay_ucode  The ucode to register\n @param      overlay_id     The ID to register the overlay with. This ID\n                            must be preshifted by 28 (eg: 0x40000000).\n\n @see #rspq_overlay_register"]
    pub fn rspq_overlay_register_static(overlay_ucode: *mut rsp_ucode_t, overlay_id: u32);
}
extern "C" {
    #[doc = " @brief Unregister a ucode overlay from the RSP queue engine.\n\n This function removes an overlay that has previously been registered\n with #rspq_overlay_register or #rspq_overlay_register_static from the\n queue engine. After calling this function, the specified overlay ID\n (and consecutive IDs in case the overlay has more than 16 commands)\n is no longer valid and must not be used to write new commands into the queue.\n\n Note that when new overlays are registered, the queue engine may recycle\n IDs from previously unregistered overlays.\n\n @param      overlay_id  The ID of the ucode (as returned by\n                         #rspq_overlay_register) to unregister."]
    pub fn rspq_overlay_unregister(overlay_id: u32);
}
extern "C" {
    #[doc = " @brief Return a pointer to the overlay state (in RDRAM)\n\n Overlays can define a section of DMEM as persistent state. This area will be\n preserved across overlay switching, by reading back into RDRAM the DMEM\n contents when the overlay is switched away.\n\n This function returns a pointer to the state area in RDRAM (not DMEM). It is\n meant to modify the state on the CPU side while the overlay is not loaded.\n The layout of the state and its size should be known to the caller.\n\n @param      overlay_ucode  The ucode overlay for which the state pointer will be returned.\n\n @return     Pointer to the overlay state (in RDRAM)"]
    pub fn rspq_overlay_get_state(overlay_ucode: *mut rsp_ucode_t) -> *mut ::std::os::raw::c_void;
}
#[doc = " @brief A write cursor, returned by #rspq_write_begin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rspq_write_t {
    #[doc = "< value that will be written as first word"]
    pub first_word: u32,
    #[doc = "< current pointer into the RSP queue"]
    pub pointer: *mut u32,
    #[doc = "< pointer to the first word of the command"]
    pub first: *mut u32,
    #[doc = "< true if we are waiting for the first argument word"]
    pub is_first: bool,
}
#[test]
fn bindgen_test_layout_rspq_write_t() {
    const UNINIT: ::std::mem::MaybeUninit<rspq_write_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rspq_write_t>(),
        32usize,
        concat!("Size of: ", stringify!(rspq_write_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rspq_write_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rspq_write_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_word) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rspq_write_t),
            "::",
            stringify!(first_word)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rspq_write_t),
            "::",
            stringify!(pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rspq_write_t),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_first) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rspq_write_t),
            "::",
            stringify!(is_first)
        )
    );
}
extern "C" {
    #[doc = " @brief Make sure that RSP starts executing up to the last written command.\n\n RSP processes the command queue asynchronously as it is being written.\n If it catches up with the CPU, it halts itself and waits for the CPU to\n notify that more commands are available. On the contrary, if the RSP lags\n behind it might keep executing commands as they are written without ever\n sleeping. So in general, at any given moment the RSP could be crunching\n commands or sleeping waiting to be notified that more commands are available.\n\n This means that writing a command via #rspq_write is not enough to make sure\n it is executed; depending on timing and batching performed\n by RSP, it might either be executed automatically or not. #rspq_flush makes\n sure that the RSP will see it and execute it.\n\n This function does not block: it just make sure that the RSP will run the\n full command queue written until now. If you need to actively wait until the\n last written command has been executed, use #rspq_wait.\n\n It is suggested to call rspq_flush every time a new \"batch\" of commands\n has been written. In general, it is not a problem to call it often because\n it is very very fast (takes only ~20 cycles). For instance, it can be called\n after every rspq_write without many worries, but if you know that you are\n going to write a number of subsequent commands in straight line code, you\n can postpone the call to #rspq_flush after the whole sequence has been written.\n\n @code{.c}\n \t\t// This example shows some code configuring the lights for a scene.\n \t\t// The command in this sample is called CMD_SET_LIGHT and requires\n \t\t// a light index and the RGB colors for the list to update.\n      uint32_t gfx_overlay_id;\n\n \t\t#define CMD_SET_LIGHT  0x7\n\n \t\tfor (int i=0; i<MAX_LIGHTS; i++) {\n \t\t\trspq_write(gfx_overlay_id, CMD_SET_LIGHT, i,\n \t\t\t    (lights[i].r << 16) | (lights[i].g << 8) | lights[i].b);\n \t\t}\n\n \t\t// After enqueuing multiple commands, it is sufficient\n \t\t// to call rspq_flush once to make sure the RSP runs them (in case\n \t\t// it was idling).\n \t\trspq_flush();\n @endcode\n\n @note This is an experimental API. In the future, it might become\n       a no-op, and flushing could happen automatically at every #rspq_write.\n       We are keeping it separate from #rspq_write while experimenting more\n       with the RSPQ API.\n\n @note This function is a no-op if it is called while a block is being recorded\n       (see #rspq_block_begin / #rspq_block_end). This means calling this function\n       in a block recording context will not guarantee the execution of commands\n       that were queued prior to starting the block.\n"]
    pub fn rspq_flush();
}
extern "C" {
    #[doc = " @brief Create a syncpoint in the queue.\n\n This function creates a new \"syncpoint\" referencing the current position\n in the queue. It is possible to later check when the syncpoint\n is reached by the RSP via #rspq_syncpoint_check and #rspq_syncpoint_wait.\n\n @return     ID of the just-created syncpoint.\n\n @note It is not possible to create a syncpoint within a block because it\n       is meant to be a one-time event. Otherwise the same syncpoint would\n       potentially be triggered multiple times, which is not supported.\n\n @note It is not possible to create a syncpoint from the high-priority queue\n       due to the implementation requiring syncpoints to be triggered\n       in the same order they have been created.\n\n @see #rspq_syncpoint_t"]
    pub fn rspq_syncpoint_new() -> rspq_syncpoint_t;
}
extern "C" {
    #[doc = " @brief Check whether a syncpoint was reached by RSP or not.\n\n This function checks whether a syncpoint was reached. It never blocks.\n If you need to wait for a syncpoint to be reached, use #rspq_syncpoint_wait\n instead of polling this function.\n\n @param[in]  sync_id  ID of the syncpoint to check\n\n @return true if the RSP has reached the syncpoint, false otherwise\n\n @see #rspq_syncpoint_t"]
    pub fn rspq_syncpoint_check(sync_id: rspq_syncpoint_t) -> bool;
}
extern "C" {
    #[doc = " @brief Wait until a syncpoint is reached by RSP.\n\n This function blocks waiting for the RSP to reach the specified syncpoint.\n If the syncpoint was already called at the moment of call, the function\n exits immediately.\n\n @param[in]  sync_id  ID of the syncpoint to wait for\n\n @see #rspq_syncpoint_t"]
    pub fn rspq_syncpoint_wait(sync_id: rspq_syncpoint_t);
}
extern "C" {
    #[doc = " @brief Begin creating a new block.\n\n This function begins writing a command block (see #rspq_block_t).\n While a block is being written, all calls to #rspq_write\n will record the commands into the block, without actually scheduling them for\n execution. Use #rspq_block_end to close the block and get a reference to it.\n\n Only one block at a time can be created. Calling #rspq_block_begin\n twice (without any intervening #rspq_block_end) will cause an assert.\n\n During block creation, the RSP will keep running as usual and\n execute commands that have been already added to the queue.\n\n @note Calls to #rspq_flush are ignored during block creation, as the RSP\n       is not going to execute the block commands anyway."]
    pub fn rspq_block_begin();
}
extern "C" {
    #[doc = " @brief Finish creating a block.\n\n This function completes a block and returns a reference to it (see #rspq_block_t).\n After this function is called, all subsequent #rspq_write\n will resume working as usual: they will add commands to the queue\n for immediate RSP execution.\n\n To run the created block, use #rspq_block_run.\n\n @return A reference to the just created block\n\n @see rspq_block_begin\n @see rspq_block_run"]
    pub fn rspq_block_end() -> *mut rspq_block_t;
}
extern "C" {
    #[doc = " @brief Add to the RSP queue a command that runs a block.\n\n This function runs a block that was previously created via #rspq_block_begin\n and #rspq_block_end. It schedules a special command in the queue\n that will run the block, so that execution of the block will happen in\n order relative to other commands in the queue.\n\n Blocks can call other blocks. For instance, if a block A has been fully\n created, it is possible to call `rspq_block_run(A)` at any point during the\n creation of a second block B; this means that B will contain the special\n command that will call A.\n\n @param block The block that must be run\n\n @note The maximum depth of nested block calls is 8."]
    pub fn rspq_block_run(block: *mut rspq_block_t);
}
extern "C" {
    #[doc = " @brief Free a block that is not needed any more.\n\n After calling this function, the block is invalid and must not be called\n anymore.\n\n @param  block  The block\n\n @note If the block was being called by other blocks, these other blocks\n       become invalid and will make the RSP crash if called. Make sure\n       that freeing a block is only done when no other blocks reference it."]
    pub fn rspq_block_free(block: *mut rspq_block_t);
}
extern "C" {
    #[doc = " @brief Start building a high-priority queue.\n\n This function enters a special mode in which a high-priority queue is\n activated and can be filled with commands. After this function has been\n called, all commands will be put in the high-priority queue, until\n #rspq_highpri_end is called.\n\n The RSP will start processing the high-priority queue almost instantly\n (as soon as the current command is done), pausing the normal queue. This will\n also happen while the high-priority queue is being built, to achieve the\n lowest possible latency. When the RSP finishes processing the high priority\n queue (after #rspq_highpri_end closes it), it resumes processing the normal\n queue from the exact point that was left.\n\n The goal of the high-priority queue is to either schedule latency-sensitive\n commands like audio processing, or to schedule immediate RSP calculations\n that should be performed right away, just like they were preempting what\n the RSP is currently doing.\n\n It is possible to create multiple high-priority queues by calling\n #rspq_highpri_begin / #rspq_highpri_end multiple times with short\n delays in-between. The RSP will process them in order. Notice that\n there is a overhead in doing so, so it might be advisable to keep\n the high-priority mode active for a longer period if possible. On the\n other hand, a shorter high-priority queue allows for the RSP to\n switch back to processing the normal queue before the next one\n is created.\n\n @note It is not possible to create a block while the high-priority queue is\n       active. Arrange for constructing blocks beforehand.\n\n @note It is currently not possible to call a block from the\n       high-priority queue. (FIXME: to be implemented)\n"]
    pub fn rspq_highpri_begin();
}
extern "C" {
    #[doc = " @brief Finish building the high-priority queue and close it.\n\n This function terminates and closes the high-priority queue. After this\n command is called, all following commands will be added to the normal queue.\n\n Notice that the RSP does not wait for this function to be called: it will\n start running the high-priority queue as soon as possible, even while it is\n being built."]
    pub fn rspq_highpri_end();
}
extern "C" {
    #[doc = " @brief Wait for the RSP to finish processing all high-priority queues.\n\n This function will spin-lock waiting for the RSP to finish processing\n all high-priority queues. It is meant for debugging purposes or for situations\n in which the high-priority queue is known to be very short and fast to run.\n Also note that it is not possible to create syncpoints in the high-priority queue."]
    pub fn rspq_highpri_sync();
}
extern "C" {
    #[doc = " @brief Enqueue a no-op command in the queue.\n\n This function enqueues a command that does nothing. This is mostly\n useful for debugging purposes."]
    pub fn rspq_noop();
}
extern "C" {
    #[doc = " @brief Enqueue a command that sets a signal in SP status\n\n The SP status register has 8 bits called \"signals\" that can be\n atomically set or cleared by both the CPU and the RSP. They can be used\n to provide asynchronous communication.\n\n This function allows to add a command to the queue that will set and/or\n clear a combination of the above bits.\n\n Notice that signal bits 2-7 are used by the RSP queue engine itself, so this\n function must only be used for bits 0 and 1.\n\n @param[in]  signal  A signal set/clear mask created by composing SP_WSTATUS_*\n                     defines.\n\n @note This is an advanced function that should be used rarely. Most\n synchronization requirements should be fulfilled via #rspq_syncpoint_new which is\n easier to use."]
    pub fn rspq_signal(signal: u32);
}
extern "C" {
    #[doc = " @brief Enqueue a command to do a DMA transfer from DMEM to RDRAM\n\n @param      rdram_addr  The RDRAM address (destination, must be aligned to 8)\n @param[in]  dmem_addr   The DMEM address (source, must be aligned to 8)\n @param[in]  len         Number of bytes to transfer (must be multiple of 8)\n @param[in]  is_async    If true, the RSP does not wait for DMA completion\n                         and processes the next command as the DMA is in progress.\n                         If false, the RSP waits until the transfer is finished\n                         before processing the next command.\n\n @note The argument is_async refers to the RSP only. From the CPU standpoint,\n       this function is always asynchronous as it just adds a command\n       to the queue."]
    pub fn rspq_dma_to_rdram(
        rdram_addr: *mut ::std::os::raw::c_void,
        dmem_addr: u32,
        len: u32,
        is_async: bool,
    );
}
extern "C" {
    #[doc = " @brief Enqueue a command to do a DMA transfer from RDRAM to DMEM\n\n @param[in]  dmem_addr   The DMEM address (destination, must be aligned to 8)\n @param      rdram_addr  The RDRAM address (source, must be aligned to 8)\n @param[in]  len         Number of bytes to transfer (must be multiple of 8)\n @param[in]  is_async    If true, the RSP does not wait for DMA completion\n                         and processes the next command as the DMA is in progress.\n                         If false, the RSP waits until the transfer is finished\n                         before processing the next command.\n\n @note The argument is_async refers to the RSP only. From the CPU standpoint,\n       this function is always asynchronous as it just adds a command\n       to the queue."]
    pub fn rspq_dma_to_dmem(
        dmem_addr: u32,
        rdram_addr: *mut ::std::os::raw::c_void,
        len: u32,
        is_async: bool,
    );
}
#[doc = "< Placeholder for no format defined"]
pub const tex_format_t_FMT_NONE: tex_format_t = 0;
#[doc = "< Format RGBA 5551 (16-bit)"]
pub const tex_format_t_FMT_RGBA16: tex_format_t = 2;
#[doc = "< Format RGBA 8888 (32-bit)"]
pub const tex_format_t_FMT_RGBA32: tex_format_t = 3;
#[doc = "< Format YUV2 4:2:2 (data interleaved as YUYV)"]
pub const tex_format_t_FMT_YUV16: tex_format_t = 6;
#[doc = "< Format CI4: color index 4-bit (paletted, 2 indices per byte)"]
pub const tex_format_t_FMT_CI4: tex_format_t = 8;
#[doc = "< Format CI8: color index 8-bit (paletted, 1 index per byte)"]
pub const tex_format_t_FMT_CI8: tex_format_t = 9;
#[doc = "< Format IA4: 3-bit intensity + 1-bit alpha (4-bit per pixel)"]
pub const tex_format_t_FMT_IA4: tex_format_t = 12;
#[doc = "< Format IA8: 4-bit intensity + 4-bit alpha (8-bit per pixel)"]
pub const tex_format_t_FMT_IA8: tex_format_t = 13;
#[doc = "< Format IA16: 8-bit intensity + 8-bit alpha (16-bit per pixel)"]
pub const tex_format_t_FMT_IA16: tex_format_t = 14;
#[doc = "< Format I4: 4-bit intensity (4-bit per pixel)"]
pub const tex_format_t_FMT_I4: tex_format_t = 16;
#[doc = "< Format I8: 8-bit intensity (8-bit per pixel)"]
pub const tex_format_t_FMT_I8: tex_format_t = 17;
#[doc = " @brief Pixel format enum\n\n This enum defines the pixel formats that can be used for #surface_t buffers.\n The list corresponds to the pixel formats that the RDP can use as textures.\n\n Notice that only some of those can be used by RDP as framebuffer (specifically,\n #FMT_RGBA16, #FMT_RGBA32 and #FMT_CI8). Moreover, the CPU-based graphics library\n graphics.h only accepts surfaces in either #FMT_RGBA16 or #FMT_RGBA32 as target buffers."]
pub type tex_format_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Return the name of the texture format as a string (for debugging purposes)"]
    pub fn tex_format_name(fmt: tex_format_t) -> *const ::std::os::raw::c_char;
}
#[doc = "@cond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct surface_s {
    #[doc = "< Flags (including pixel format)"]
    pub flags: u16,
    #[doc = "< Width in pixels"]
    pub width: u16,
    #[doc = "< Height in pixels"]
    pub height: u16,
    #[doc = "< Stride in bytes (length of a row)"]
    pub stride: u16,
    #[doc = "< Buffer pointer"]
    pub buffer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_surface_s() {
    const UNINIT: ::std::mem::MaybeUninit<surface_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<surface_s>(),
        16usize,
        concat!("Size of: ", stringify!(surface_s))
    );
    assert_eq!(
        ::std::mem::align_of::<surface_s>(),
        8usize,
        concat!("Alignment of ", stringify!(surface_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(surface_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(surface_s),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(surface_s),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(surface_s),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(surface_s),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    #[doc = " @brief Allocate a new surface in memory\n\n This function allocates a new surface with the specified pixel format,\n width and height. The surface must be freed via #surface_free when it is\n not needed anymore.\n\n A surface allocated via #surface_alloc can be used as a RDP frame buffer\n (passed to #rdp_attach) because it is guaranteed to have the required\n alignment of 64 bytes, provided it is using one of the formats supported by\n RDP as a framebuffer target (`FMT_RGBA32`, `FMT_RGBA16` or `FMT_I8`).\n\n @param[in]  format   Pixel format of the surface\n @param[in]  width    Width in pixels\n @param[in]  height   Height in pixels\n @return              The initialized surface"]
    pub fn surface_alloc(format: tex_format_t, width: u32, height: u32) -> surface_t;
}
extern "C" {
    #[doc = " @brief Initialize a surface_t structure, pointing to a rectangular portion of another\n        surface.\n\n The surface returned by this function will point to a portion of the buffer of\n the parent surface, and will have of course the same pixel format.\n\n @param[in]  parent   Parent surface that will be pointed to\n @param[in]  x0       X coordinate of the top-left corner within the parent surface\n @param[in]  y0       Y coordinate of the top-left corner within the parent surface\n @param[in]  width    Width of the surface that will be returned\n @param[in]  height   Height of the surface that will be returned\n @return              The initialized surface"]
    pub fn surface_make_sub(
        parent: *mut surface_t,
        x0: u32,
        y0: u32,
        width: u32,
        height: u32,
    ) -> surface_t;
}
extern "C" {
    #[doc = " @brief Free the buffer allocated in a surface.\n\n This function should be called after a surface allocated via #surface_alloc is not\n needed anymore.\n\n Calling this function on surfaces allocated via #surface_make or #surface_make_sub\n (that is, surfaces initialized with an existing buffer pointer) has no effect but\n clearing the contents of the surface structure.\n\n @param[in]  surface   The surface to free"]
    pub fn surface_free(surface: *mut surface_t);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
